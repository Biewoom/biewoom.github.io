---
layout: post
title: "Trie: 자동 완성의 비밀!"
# permalink: /datastructure/non_linear_ds/trie
categories:
  - non-linear-ds
  - advanced
image:
  path: /assets/images/ds/non-linear/google.png
  thumbnail: /assets/images/ds/non-linear/google.png
comments: true
excerpt: 검색어, 채팅의 자동 완성 안에는 어떤 알고리즘을 쓸까?
---
혹시 검색어, 채팅 추천이 어떤 원리로 운영되는 지 궁금하신 적 있으신가요?<br/>
현실적으로는 프론트, 백, 데이터 프로세싱 등의 다방면의 접근이 필요하지만<br/>
그 중 백에서 사용 되는 모델은 **트라이(Trie)**를 기반으로 하는 것이 많습니다!<br/>

> ※ 현재 대부분 기업은 Basic이 아닌 훨씬 최적화, 변형된 트라이를 사용합니다.

# 트라이는 어떤 기능을 하나요?

트라이는 String-search, Substring-search 등을 수행합니다<br/>
이 중 **String-search** 기능을 예로 설명하겠습니다.<br/>
우리는 검색어 관리팀이고, n개 글자의 리스트를 가지고 있다고 합시다.<br/>
가진 리스트는 { '한국은행', '한국만세', '천조국', '일본', '국물',..., '국뽕'}<br/>

이 때, 한 유저가 기존의 리스트에 '국뽕'이라는 글자가 있는 지가 궁금합니다.<br/>
**핵심: 어떻게 하면 리스트에서 이 글자가 있는 지를 효율적으로 알 수 있을까요??**<br/>

# Brute-force 하게 해봅시다.
![image]({% link /assets/images/ds/non-linear/trie-brute-force.png %} )

어렵게 생각하지 말고 리스트 안의 것 모두를 우리의 Query인 '국뽕'과 하나씩 비교합시다<br/>
한국은행과 국뽕을 먼저 비교하고, 다음은 한국만세, 다음은 일본 ... <br/>
n-1번 까지 있던 모든 글자와는 틀렸다는 것을 확인하고 마지막에서 와서야<br/>
국뽕과 비교를 하게 되고, 이 리스트에는 '국뽕'이라는 글자가 발견되었습니다.<br/>

이를 시간 효율성에 비추어 생각하면 최악의 경우는 **O(N*M)**입니다.<br/>
이 때, N = 리스트의 길이, M = 쿼리 글자의 길이입니다.<br/>
운좋게, 쿼리가 하나 일 경우에는 이 Brute-force 방법도 고려 해볼만 합니다만<br/>

만약, **쿼리가 하나가 아니라, ['국뽕', '일본', ..]처럼 K개의 쿼리가 있는 리스트이면**,<br/>
각각 쿼리도 똑같은 과정을 거치기에 시간효율성은 **O(N* M *K)**가 될 것입니다.<br/>
위의 시간 효율성은 굉장히 비효율적이며, 현실에서도 적용하기 어렵습니다.<br/>
이것을 해결하기 위해서 아래와 같은 Trie라는 구조가 고안되었습니다.<br/>

# 트라이 추상적 구조
핵심 아이디어는 **String(글자)를 하나 하나 쪼개어 트리로 저장한다**입니다.<br/>
예를 들면 '한국만세' -> ['한', '국', '만', 세'], '일본'->['일', '본']<br/>
과 같이 모두 쪼갠 후에 아래와 같은 트리 형태로 저장을 합니다.<br/>






# 트라이의 장단점

# 구현 아이디어
1. linked-list
2. Hashable dict
3. iteration
4. tree

# 실제 구현
