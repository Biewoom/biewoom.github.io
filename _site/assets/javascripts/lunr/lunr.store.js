var store = [{
        "title": "카카오 테스트: 자물쇠와 열쇠",
        "excerpt":"핵심개념 및 팁: 첫 번쨰: 효율적인 Time-complexity를 크게 고민하시지는 않아도 될 거 같습니다.원체, N과 M의 최대 범위값이 크지 않아서 여러 번의 Nested-loop하셔도 통과가 가능합니다.저 같은 경우, O( (n+m)2 * (m2 + n2 ) ) 이었는데, 통과가 되었습니다. 두 번째: 회전과 이동의 개념을 정확하게 이해하셔야 합니다.회전들은 서로 배반적으로 작용합니다. i.e 경우의 수에서 말하는 합의 법칙(or)이 성립합니다.저도 수학적인 증명까지는 못했으나, 종이에, 3*3 정도 grid를 그리셔서 회전과 이동을 해보시면 아시게 될겁니다. 세 번째: Virtual Matrix를 이용하라.문제에서 제시한 조건을 충족하면서 Lock과 keys의 값을 효율적으로 비교하기 위해 크기가(n + 2m)(n + 2*m)인 큰 Virtual Matrix를 새로 그려서 값을 비교했습니다.Space complexity가 약간 커지지만, 코드가 이해하기 쉬워집니다. 마지막: XOR을 이용해서 홈과 돌기를 서로 비교하시면 더욱 깔끔한 코드가 될거같습니다. Code: import osimport sysdef Counterclockwise(matrix):    new_matrix = [[0]*len(matrix) for i in range(len(matrix))]    for i in range(len(matrix)):        for j in range(len(matrix)):            new_matrix[len(matrix)- 1 - j][i] = matrix[i][j]    return new_matrixdef solution(keys, locks):    m = len(keys); n = len(locks); lock_x = lock_y = m-1    options = [0, 90, 180, 270]    for op in options:        if op != 0: keys = Counterclockwise(keys)        for i in range(0, m+n):            for j in range(0, m+n):                VirtualMatrix = [[None]*(n+2*m) for i in range((n+2*m))]                key_x = i; key_y = j                for x in range(0, m):                    for y in range(0, m):                        VirtualMatrix[key_x+x][key_y+y] = keys[x][y]                Unlock = True                for z in range(0, n):                    for k in range(0, n):                        if VirtualMatrix[lock_x+z][lock_y+k] is None:                            if locks[z][k] == 0: Unlock = False                            else: continue                        else:                            if VirtualMatrix[lock_x+z][lock_y+k]^locks[z][k] != 1: Unlock = False                            else: continue                if Unlock: return True    return FalseCode-review:   논리구조가 간단명료한가?          VirtualMatrix를 사용하니 논리구조 자체는 논리정연했다.        코드를 Readible 하게 적었는가?          x,y,z,k 등의 변수 이름은 친절하지 않게 적었다.        최적화는 하였는가?          전체적인 Complete-search를 해야해서 좋은 time-complexity라고 할 수는 없다.      논리구조는 명료했지만 space-complexity가 좀 더 비효율적이 되었다.      ","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/13/Lock.html"
      },{
        "title": "카카오 테스트:가사 검색",
        "excerpt":"핵심 개념:   Trie  prefix and suffix  string 길이팁: 1) 문제의 조건을 보시면, query안에,  ‘?’가 있을 수 있는 경우는:  prefix 또는 suffix 또는 ‘?????’ 이렇게 세 가지 경우가 있습니다.  그래서 트리 하나로 해결하시는 것보다, 이 경우들을 다 고려하시면서 한 개이상의 Trie를 만드시는 게 좋습니다. 2) 이 문제에서는 substring을 구하는 문제가 아니고 match하는 string을 구하는 것이기 때문에 아예 처음부터, string의 길이를 이용하시는 것도 좋습니다. 3) 다른 응용으로는, 단순한 Trie가 아니라, Trie 내부에, subtree의 노드 수를 계속 추적할 수 있는 값을 추가하시면 훨씬 효율적입니다. More Tip:문제에서 중복이 있을 수 있다라는 이야기가 나와서 중복을 없애고 시작하면, 좀 더 효율적이지 않나? 라고생각이 들 수도 있습니다. 하지만 사실 이건 크게 의미가 없습니다. 우리는 이전에 같은 string이 있었는지 체크하기 위해 hash function을 적용 하는 과정에서 string 전체를 적어도 한 번을 다 돌아야 합니다.그러므로, O(len(string))으로 Trie에서의 탐색하는 것과 같은 time complexity를 가집니다. Code 풀이는 위의 설명을 참조해서 코드를 직접 보시면서 이해하면 좋겠습니다. import osimport sysfrom collections import defaultdictclass Trie:    def __init__(self):        self.root = {} # chr|visited    def insert(self, s):        cur = self.root        while s:            if s[0] not in cur: cur[s[0]] = [ {} , 0 ]            cur[s[0]][1] += 1            cur = cur[s[0]][0]            s = s[1:]    def find(self, s)-&gt;int:        cur = self.root; pre_v = 0        while s:            if s[0] == '?': return pre_v            else:                if s[0] not in cur: return 0                pre_v = cur[s[0]][1]; cur = cur[s[0]][0]            s = s[1:]        return pre_vdef solution(words, queries):    prefix_dict = defaultdict(Trie)    suffix_dict = defaultdict(Trie)    len_dict = defaultdict(int)    result = []    for word in words:        prefix_dict[len(word)].insert(word)        suffix_dict[len(word)].insert(word[::-1])        len_dict[len(word)] += 1    for q in queries:        if q[0] == '?' and q[-1] == '?':            result.append(len_dict[len(q)])        elif q[-1] == '?': #preffix_query            result.append( prefix_dict[len(q)].find(q))        elif q[0] == '?': #suffix_query            result.append( suffix_dict[len(q)].find(q[::-1]) )        else:            print(\"IMPOSSIBLE\", q)    return result","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/13/search_lyrics.html"
      },{
        "title": "Trie: 자동 완성의 비밀!",
        "excerpt":"혹시 검색어, 채팅 추천이 어떤 원리로 운영되는 지 궁금하신 적 있으신가요?현실적으로는 프론트, 백, 데이터 프로세싱 등의 다방면의 접근이 필요하지만그 중 백에서 사용 되는 모델은 트라이(Trie)를 기반으로 하는 것이 많습니다! 이는 트라이의 기능이 검색어를 효율적으로 찾는 것에 도움이 되기 떄문인데요.우리는 여기서 Basic 한 Trie에 간단히 대해서 알아보겠습니다.   ※ 현재 대부분 기업은 Basic이 아닌 훨씬 최적화, 변형된 트라이를 사용합니다. 트라이는 어떤 기능을 하나요? 트라이는 String-search, Substring-search 등을 수행합니다이 중 String-search 기능을 예로 설명하겠습니다.우리는 검색어 관리팀이고, n개 낱말의 리스트를 가지고 있다고 합시다.가진 리스트는 {‘한국은행’, ‘한국만세’, ‘일본’, ‘국장’, ‘국물’,…, ‘국뽕’} 이 때, 한 유저가 기존의 리스트에 ‘국뽕‘이라는 낱말이 있는 지가 궁금합니다.핵심: 어떻게 하면 리스트에서 이 낱말이 있는 지를 효율적으로 알 수 있을까요??※ 다음으로 넘어가기 전에 혼자 한 번 고민해봅시다! Brute-force 하게 해봅시다.  어렵게 생각하지 말고 리스트 안의 것 모두를 우리의 Query인 ‘국뽕’과 하나씩 비교합시다한국은행과 국뽕을 먼저 비교하고, 다음은 한국만세, 다음은 일본 … 등등 n-1번 까지 있던 모든 글자와는 틀렸다는 것을 확인하고 마지막에서 와서야 겨우‘국뽕’과 비교를 할 수 있게 되고, 우리는 ‘국뽕’이라는 낱말이 있다는 것을 발견합니다. 이를 시간 효율성에 비추어 생각하면 최악의 경우는 O(N*M)입니다.이 때, N = 리스트의 길이, M = 쿼리 낱말의 길이입니다.운좋게, 쿼리가 하나 일 경우에는 이 Brute-force 방법도 참아 줄만 합니다만 만약 궁금한 게 하나의 쿼리가 아니라, [‘국뽕’, ‘일본’, ‘나라’, ..] 처럼 K 개 쿼리의 리스트이면,각각 쿼리도 똑같은 과정을 거치기에 시간효율성은 O(N* M *K)가 될 것입니다.위의 시간 효율성은 굉장히 비효율적이며, 현실에서도 적용하기 어렵습니다.이것을 해결하기 위해서 아래와 같은 트라이(Trie)라는 구조가 고안되었습니다. 트라이의 구조 트라이의 아이디어는  낱말을 하나 하나 글자로 쪼개어 트리로 저장한다입니다.예를 들면 ‘한국은행’ -&gt; [‘한’, ‘국’, ‘은’, 행’], ‘일본’ -&gt; [‘일’, ‘본’]과 같이 모두 쪼갠 후에 아래와 같은 과정을 거쳐 트리 형태로 저장을 합니다. Trie를 만드는 단계:만드는 단계는 아래와 같은 두 가지 경우로 진행됩니다.   낱말을 글자로 쪼갠 후 노드에 공통되는 글자가 있으면 그 글자 노드로 진행  낱말을 글자로 쪼꺤 후 노드에 그 글자가 없다면, 글자에 해당되는 노드를 만들고 진행아래는 Trie를 만드는 과정 중 ‘한국만세’ 라는 낱말을 넣는 차례입니다.  아래는 Trie를 만드는 과정 중 ‘일본’ 이라는 낱말을 넣는 차례입니다.  Trie를 다 만든 단계:위의 과정이 모두 끝나면 아래와 같습니다.  Query를 찾는 단계:우리가 찾고싶은 쿼리는 ‘국뽕’이라고 한다면 먼저 ‘국‘을 가진 노드를 찾고‘국‘에 해당하는 다음 노드로 넘어간다음, ‘뽕‘이라는 노드를 찾으면 됩니다  이번에는 ‘일본’이라는 낱말을 찾는 경우입니다.  이번에는 ‘나라’ 라는 낱말을 찾는 경우인데, 첫 번째 노드부터, ‘나’ 라는 글자가존재하지 않습니다. 따라서 여기엔 ‘나라’ 라는 낱말는 없다 라는 걸 바로 알 수 있습니다  트라이의 장단점 장점:Query를 찾을 때, Brute-force를 이용하는 것보다 좋은 time-complexity를 가집니다.특히, 처리하는 Query의 수가 많아지면 질수록 이 구조은 정말 유용합니다. 구현하는 것도 어렵지 않고 아이디어도 간단해서 여러 응용을 하기 좋습니다.예로: Visted 같은 변수를 추가해서, 갯수를 추적하는 것도 가능합니다. 단점:space-complexity면에서는 기존의 것보다 비효율적입니다.대부분 구현과정에서 Map을 쓰게 되는데, 이 때 space가 꽤 듭니다. 쿼리가 워낙 적으면 오히려 시간이 걸릴 수도 있다.일단 이 구조는 만들 때도 String hash를 하기 때문에 시간이 걸립니다.따라서 쿼리 양은 되게 적고, 저장되어있는 단어는 상대적으로 많을 때오히려 Brute-force한 것보다도 더 안좋은 execution-time을 가질 수도 있습니다. 실제 구현 by Python 구현 아이디어:   linked-list  Dictionary  iteration  TreeCode: class Trie:    def __init__(self):        self.root = {}    def insert(self, s):        cur = self.root        while s:          if s[0] not in cur: cur[s[0]] = {}          cur = cur[s[0]]          s = s[1:]        cur[0] = {}    def find(self, s)-&gt;bool:        cur = self.root;        while s:            if s[0] not in cur: return False            cur = cur[s[0]]            s = s[1:]        if 0 in cur: return True        else: return False","categories": ["non-linear-ds","advanced-ds"],
        "tags": [],
        "url": "http://localhost:4000/non-linear-ds/advanced-ds/2020/04/14/Trie.html"
      },{
        "title": "카카오 테스트:블록 이동",
        "excerpt":"PS에서는 나오기 힘든 코딩을 요구합니다.카카오 Tech 측에서도, ‘상당한 난이도의 코딩을 요구한다.’ 라고 언급할 정도로보통 problemSolving 문제 이상의 상당한 구현력을 요구합니다. 핵심 개념:   BFS  HashMap  Memoization풀이법:   최소 시간을 구하기 위해서 BFS을 이용한 Outer-loop에서 최소 시간인 time을 추적합니다. 마지막 칸을 만나게 되면 time을 Return 합니다.  경우의 수 가지치기를 위해, HashMap을 이용한 memoization을 활용해 이미 지났던 경로를 다시 지날 경우는 Queue에서 제외합니다.  이 때, HashMap 안에는 (좌표1, 좌표2) 가 하나의 키의 역할을 하며   - 조건1  rotate할 때, 문제 조건에 따르면, 축 (axis) 대각측 칸이 0임을 계속 추적해야 하는데, 이 점에서 저는 어떤 패턴도 발견하지 못해서 모든 경우에 맞게 하드코딩을 하였습니다.조건1이 필요한 이유:i.e; ((0,0), (0,1)) 와 ((0,1), (0,0)) 같은 건 같은 하나의 key로 취급을 해야하기 때문입니다. HardCoding 참고: style: 가로모양 or 세로모양, axis: 좌표1가 축 or 좌표2가 축, direction: 시계방향 or 반시계 방향 import osimport sysfrom collections import defaultdict# style|axis|direcitonValueArray = [[[None]*2 for i in range(2)] for i in range(2)]CheckArray = [[[None]*2 for i in range(2)] for i in range(2)]def check(coord1, coord2, board):    x1, y1 = coord1; x2, y2 = coord2    if min(x1, y1, x2, y2) &lt; 0: return False    elif max(x1, y1, x2, y2) &gt;= len(board): return False    elif board[x1][y1] == 1 or board[x2][y2] == 1: return False    else: return Truedef goNEWS(coord1, coord2, i):    move = [(-1,0), (0, 1), (0, -1), (1,0)]    new_coord1 = (coord1[0]+move[i][0], coord1[1]+move[i][1]); new_coord2 = (coord2[0]+move[i][0], coord2[1]+move[i][1])    return sorted((new_coord1, new_coord2))def rotate(coord1, coord2, board, axis, direction):    global ValueArray, CheckArray    axis_coord = coord1 if axis == 0 else coord2    style = 0 if coord2[1] &gt; coord1[1] else 1    Check = CheckArray[style][axis][direction]    Value = ValueArray[style][axis][direction]    Check_coord = (axis_coord[0] + Check[0], axis_coord[1]+Check[1])    if 0 &lt;= Check_coord[0] &lt; len(board) and 0 &lt;= Check_coord[1] &lt; len(board) and board[Check_coord[0]][Check_coord[1]] == 0:        return sorted( ( (axis_coord[0]+Value[0], axis_coord[1]+Value[1]), axis_coord) )    else:        return ((-1,-1), (-1,-1))def initialize(ValueArray, CheckArray):    CheckArray[0][0][0] = (-1,1);   ValueArray[0][0][0] = (-1,0)    CheckArray[0][0][1] = (1,1);    ValueArray[0][0][1] = (1,0)    CheckArray[0][1][0] = (-1,-1);  ValueArray[0][1][0] = (-1,0)    CheckArray[0][1][1] = (1,-1);   ValueArray[0][1][1] = (1,0)    CheckArray[1][0][0] = (1,1);    ValueArray[1][0][0] = (0,1)    CheckArray[1][0][1] = (1,-1);   ValueArray[1][0][1] = (0,-1)    CheckArray[1][1][0] = (-1,1);   ValueArray[1][1][0] = (0,1)    CheckArray[1][1][1] = (-1,-1);  ValueArray[1][1][1] = (0,-1)def solution(board):    global ValueArray, CheckArray    initialize(ValueArray, CheckArray)    HashMap = defaultdict(int)    Q = [( (0, 0), (0, 1) )]    time = 0    while True:        next_Q = []        while Q:            coord1, coord2 = Q.pop(0)            if not check(coord1, coord2, board): continue            if (coord1, coord2) in HashMap and HashMap[(coord1, coord2)] &lt;= time: continue            if coord2[0] == len(board)-1 and coord2[1] == len(board)-1: return time            HashMap[(coord1, coord2)] = time            for i in range(4):                next_Q.append(tuple(goNEWS(coord1, coord2, i)))            for axis in range(2):                for direction in range(2):                    next_Q.append(tuple(rotate(coord1, coord2, board, axis, direction)))        time += 1        Q = next_Q","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/15/move-block.html"
      },{
        "title": "BFS:주변 찾기의 비밀!",
        "excerpt":"지도 앱을 이용해 최단 경로를 찾거나 주변에 가까운 음식점은 어떤 것이 있는지?등의 기능을 사용해 보신 적이 있으신가요? 이 안에는 어떤 원리가 숨겨져 있을까요?이 안에는 프론트, 백, 데이터프로세싱, GPS등 여러 기술이 복잡하게 있지만그 중 백에서는 BFS을 기반한 알고리즘이 쓰이는 경우가 많습니다.과연 BFS란 머고 어떤 기능으로 이것을 통해 길 찾기를 할 수 있는지 알아보겠습니다. BFS는 어떤 기능을 하나요? BFS는 길찾기 또는 주변탐색 같은 노드탐색기능을 수행할 수 있습니다.비슷한 기능을 수행하는 알고리즘으론 DFS(depth first search)가 있습니다. BFS는 Breath-First-search의 약자로 너비-우선-탐색을 의미하는데요.너비를 우선 탐색하기 때문에, 가장 가까운 노드 탐색이나, 주변에 있는 노드를 탐색하는 경우는 DFS보다 좀 더 효율적이라는 장점을 가집니다! 이 중 가장 가까운 노드 탐색 기능을 예로 들어 자세히 설명하겠습니다. 철수가 여행 중 배가 고파 짜장면을 먹을려고 하는데, 이 동네에는 3개의 중국집이 있습니다.철수는 너무 배가 고파서 현재 위치에서 가장 가까운 중국집에 가서 짜장면을 먹으려고 합니다.  위는 동네의 지도이고 철수는 어떻게 하면 효율적으로 가장 가까운 중국집을 찾을까요?※ 다음으로 넘어가기 전에 혼자 한 번 고민해봅시다! brute-force하게 해봅시다. 일단 철수 위치에서 갈 수 있는 모든 노드를 조사하고 중국집을 찾았다면중국집 거리를 모두 비교해서 가장 가까운 중국집을 알아내는 방법입니다.  위처럼 구하면, 이 동네에서 현 위치에서 가장 가까운 중국집은 황룡반점이다.라는 것을 알 수 있고, 철수는 현 위치에서 1M 떨어진 청룡반점으로 갈 것 입니다. 하지만 이 때 time-complexity를 구해보면, O(N+M) 입니다.이 떄 N = nodes의 수, M = Edges의 수 = 길의 수로 모든 노드와 길을 가야 하는 Time-complexity를 가집니다.이는 동네가 커져서, Nodes와 edges가 많아질수록 굉장히 비효율적이 됩니다. 이 비효율성을 해결하기 위해서 BFS라는 알고리즘을 고안하게 되었습니다. BFS: BFS를 이용한 풀이법은 거리를 기준으로 Greedy하게 문제를 접근해서 푸는 것입니다.한마디로, 가까운 거리의 노드부터 차례 차례 구하다 보면 가장 먼저 만난 노드가 정답이다.라는 아이디어인데, 먼저, 거리를 기준으로 노드를 구한다는 것을 설명하겠습니다. 거리를 기준으로 노드를 구하다는 것은 그림으로 표한하면 아래와 같습니다.먼저 거리가 1m인 Node들을 구하는 경우입니다.  거리가 2m인 Node 들을 구하는 경우입니다.  마지막으로 거리가 3m인 Node들을 구하는 경우입니다.  우리는 위의 BFS를 사용해 문제를 쉽게 풀 수 있습니다.바로 첫 번쨰의 계산과정만 하고 두 번쨰, 세 번째 계산은 생략한다.라는 것입니다.첫 번째 과정에서 중국집을 만나면, 그 중국집이 바로 가장 가까운 중국집입니다.이유는 다음 과정에서의 중국집은 이 중국집보다 멀리 있을 수 밖에 없기 때문입니다. BFS의 장단점: 실제 구현 by Python ","categories": ["graph-theory","basic"],
        "tags": [],
        "url": "http://localhost:4000/graph-theory/basic/2020/04/16/bfs.html"
      }]
