var store = [{
        "title": "카카오 테스트: 자물쇠와 열쇠",
        "excerpt":"핵심개념 및 팁: 첫 번쨰: 효율적인 Time-complexity를 크게 고민하시지는 않아도 될 거 같습니다.원체, N과 M의 최대 범위값이 크지 않아서 여러 번의 Nested-loop하셔도 통과가 가능합니다.저 같은 경우, O( (n+m)2 * (m2 + n2 ) ) 이었는데, 통과가 되었습니다. 두 번째: 회전과 이동의 개념을 정확하게 이해하셔야 합니다.회전들은 서로 배반적으로 작용합니다. i.e 경우의 수에서 말하는 합의 법칙(or)이 성립합니다.저도 수학적인 증명까지는 못했으나, 종이에, 3*3 정도 grid를 그리셔서 회전과 이동을 해보시면 아시게 될겁니다. 세 번째: Virtual Matrix를 이용하라.문제에서 제시한 조건을 충족하면서 Lock과 keys의 값을 효율적으로 비교하기 위해 크기가(n + 2m)(n + 2*m)인 큰 Virtual Matrix를 새로 그려서 값을 비교했습니다.Space complexity가 약간 커지지만, 코드가 이해하기 쉬워집니다. 마지막: XOR을 이용해서 홈과 돌기를 서로 비교하시면 더욱 깔끔한 코드가 될거같습니다. Code: import osimport sysdef Counterclockwise(matrix):    new_matrix = [[0]*len(matrix) for i in range(len(matrix))]    for i in range(len(matrix)):        for j in range(len(matrix)):            new_matrix[len(matrix)- 1 - j][i] = matrix[i][j]    return new_matrixdef solution(keys, locks):    m = len(keys); n = len(locks); lock_x = lock_y = m-1    options = [0, 90, 180, 270]    for op in options:        if op != 0: keys = Counterclockwise(keys)        for i in range(0, m+n):            for j in range(0, m+n):                VirtualMatrix = [[None]*(n+2*m) for i in range((n+2*m))]                key_x = i; key_y = j                for x in range(0, m):                    for y in range(0, m):                        VirtualMatrix[key_x+x][key_y+y] = keys[x][y]                Unlock = True                for z in range(0, n):                    for k in range(0, n):                        if VirtualMatrix[lock_x+z][lock_y+k] is None:                            if locks[z][k] == 0: Unlock = False                            else: continue                        else:                            if VirtualMatrix[lock_x+z][lock_y+k]^locks[z][k] != 1: Unlock = False                            else: continue                if Unlock: return True    return FalseCode-review:   논리구조가 간단명료한가?          VirtualMatrix를 사용하니 논리구조 자체는 논리정연했다.        코드를 Readible 하게 적었는가?          x,y,z,k 등의 변수 이름은 친절하지 않게 적었다.        최적화는 하였는가?          전체적인 Complete-search를 해야해서 좋은 time-complexity라고 할 수는 없다.      논리구조는 명료했지만 space-complexity가 좀 더 비효율적이 되었다.      ","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/13/Lock.html"
      },{
        "title": "카카오 테스트: 가사 검색",
        "excerpt":"핵심 개념:   Trie  [Hash]팁: Code: 풀이는 위의 설명을 참조해서 코드를 직접 보시면서 이해하면 좋겠습니다. ","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/13/search_lyrics.html"
      },{
        "title": "Trie: 자동 완성의 비밀!",
        "excerpt":"혹시 검색어, 채팅 추천이 어떤 원리로 운영되는 지 궁금하신 적 있으신가요?현실적으로는 프론트, 백, 데이터 프로세싱 등의 다방면의 접근이 필요하지만그 중 백에서 사용 되는 모델은 트라이(Trie)를 기반으로 하는 것이 많습니다!   ※ 현재 대부분 기업은 Basic이 아닌 훨씬 최적화, 변형된 트라이를 사용합니다. 트라이는 어떤 기능을 하나요? 트라이는 String-search, Substring-search 등을 수행합니다이 중 String-search 기능을 예로 설명하겠습니다.우리는 검색어 관리팀이고, n개 글자의 리스트를 가지고 있다고 합시다.가진 리스트는 { ‘한국은행’, ‘한국장학재단’, ‘천조국’, ‘일본’, ‘국물’,…, ‘국뽕’} 이 때, 한 유저가 기존의 리스트에 ‘국뽕’이라는 글자가 있는 지가 궁금합니다.핵심: 어떻게 하면 리스트에서 이 글자가 있는 지를 효율적으로 알 수 있을까요?? Brute-force 하게 해봅시다.  어렵게 생각하지 말고 리스트 안의 것 모두를 우리의 Query인 ‘국뽕’과 하나씩 비교합시다한국은행과 국뽕을 먼저 비교하고, 다음은 한국장학재단, 다음은 일본 … n-1번 까지 있던 모든 글자와는 틀렸다는 것을 확인하고 마지막에서 와서야국뽕과 비교를 하게 되고, 이 리스트에는 ‘국뽕’이라는 글자가 발견되었습니다. 이를 시간 효율성에 비추어 생각하면 최악의 경우는 O(N*M)입니다.이 때, N = 리스트의 길이, M = 쿼리 글자의 길이입니다.운좋게, 쿼리가 하나 일 경우에는 이 Brute-force 방법도 고려 해볼만 합니다만 만약, 쿼리가 하나가 아니라, [‘국뽕’, ‘일본’, ..]처럼 K개의 쿼리가 있는 리스트이면,각각 쿼리도 똑같은 과정을 거치기에 시간효율성은 O(N* M *K)가 될 것입니다.위의 시간 효율성은 굉장히 비효율적이며, 현실에서도 적용하기 어렵습니다.이것을 해결하기 위해서 아래와 같은 Trie라는 구조가 고안되었습니다. 아이디어와 추상적 구조 핵심 아이디어는 String(글자)를 하나 하나 쪼개어 트리로 저장한다입니다.예를 들면 ‘한국장학재단’ -&gt; [‘한’, ‘국’, ‘장’, ‘학’, ‘재’, ‘단’], ‘일본’-&gt;[‘일’, ‘본’]과 같이 모두 쪼갠 후에 아래와 같은 트리 형태로 저장을 합니다. 트라이의 장단점 구현 아이디어   linked-list  Hashable dict  iteration  tree실제 구현 ","categories": ["non-linear-ds","advanced"],
        "tags": [],
        "url": "http://localhost:4000/non-linear-ds/advanced/2020/04/14/Trie.html"
      }]
