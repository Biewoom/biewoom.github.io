var store = [{
        "title": "카카오 테스트: 자물쇠와 열쇠",
        "excerpt":"핵심개념   Matrix rotation팁 첫 번쨰: 효율적인 Time-complexity를 크게 고민하시지는 않아도 될 거 같습니다.원체, N과 M의 최대 범위값이 크지 않아서 여러 번의 Nested-loop하셔도 통과가 가능합니다.저 같은 경우, O( (n+m)2 * (m2 + n2 ) ) 이었는데, 통과가 되었습니다. 두 번째: 회전과 이동의 개념을 정확하게 이해하셔야 합니다.회전들은 서로 배반적으로 작용합니다. i.e 경우의 수에서 말하는 합의 법칙(or)이 성립합니다.저도 수학적인 증명까지는 못했으나, 종이에, 3*3 정도 grid를 그리셔서 회전과 이동을 해보시면 아시게 될겁니다. 세 번째: Virtual Matrix를 이용하라.문제에서 제시한 조건을 충족하면서 Lock과 keys의 값을 효율적으로 비교하기 위해 크기가(n + 2m)(n + 2*m)인 큰 Virtual Matrix를 새로 그려서 값을 비교했습니다.Space complexity가 약간 커지지만, 코드가 이해하기 쉬워집니다. 마지막: XOR을 이용해서 홈과 돌기를 서로 비교하시면 더욱 깔끔한 코드가 될거같습니다. Code: import osimport sysdef Counterclockwise(matrix):    new_matrix = [[0]*len(matrix) for i in range(len(matrix))]    for i in range(len(matrix)):        for j in range(len(matrix)):            new_matrix[len(matrix)- 1 - j][i] = matrix[i][j]    return new_matrixdef solution(keys, locks):    m = len(keys); n = len(locks); lock_x = lock_y = m-1    options = [0, 90, 180, 270]    for op in options:        if op != 0: keys = Counterclockwise(keys)        for i in range(0, m+n):            for j in range(0, m+n):                VirtualMatrix = [[None]*(n+2*m) for i in range((n+2*m))]                key_x = i; key_y = j                for x in range(0, m):                    for y in range(0, m):                        VirtualMatrix[key_x+x][key_y+y] = keys[x][y]                Unlock = True                for z in range(0, n):                    for k in range(0, n):                        if VirtualMatrix[lock_x+z][lock_y+k] is None:                            if locks[z][k] == 0: Unlock = False                            else: continue                        else:                            if VirtualMatrix[lock_x+z][lock_y+k]^locks[z][k] != 1: Unlock = False                            else: continue                if Unlock: return True    return FalseCode-review:   논리구조가 간단명료한가?          VirtualMatrix를 사용하니 논리구조 자체는 논리정연했다.        코드를 Readible 하게 적었는가?          x,y,z,k 등의 변수 이름은 친절하지 않게 적었다.        최적화는 하였는가?          전체적인 Complete-search를 해야해서 좋은 time-complexity라고 할 수는 없다.      논리구조는 명료했지만 space-complexity가 좀 더 비효율적이 되었다.      ","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/13/Lock.html"
      },{
        "title": "카카오 테스트:가사 검색",
        "excerpt":"핵심 개념:   Trie  prefix and suffix  string 길이팁: 1) 문제의 조건을 보시면, query안에,  ‘?’가 있을 수 있는 경우는:  prefix 또는 suffix 또는 ‘?????’ 이렇게 세 가지 경우가 있습니다.  그래서 트리 하나로 해결하시는 것보다, 이 경우들을 다 고려하시면서 한 개이상의 Trie를 만드시는 게 좋습니다. 2) 이 문제에서는 substring을 구하는 문제가 아니고 match하는 string을 구하는 것이기 때문에 아예 처음부터, string의 길이를 이용하시는 것도 좋습니다. 3) 다른 응용으로는, 단순한 Trie가 아니라, Trie 내부에, subtree의 노드 수를 계속 추적할 수 있는 값을 추가하시면 훨씬 효율적입니다. More Tip:문제에서 중복이 있을 수 있다라는 이야기가 나와서 중복을 없애고 시작하면, 좀 더 효율적이지 않나? 라고생각이 들 수도 있습니다. 하지만 사실 이건 크게 의미가 없습니다. 우리는 이전에 같은 string이 있었는지 체크하기 위해 hash function을 적용 하는 과정에서 string 전체를 적어도 한 번을 다 돌아야 합니다.그러므로, O(len(string))으로 Trie에서의 탐색하는 것과 같은 time complexity를 가집니다. Code 풀이는 위의 설명을 참조해서 코드를 직접 보시면서 이해하면 좋겠습니다. import osimport sysfrom collections import defaultdictclass Trie:    def __init__(self):        self.root = {} # chr|visited    def insert(self, s):        cur = self.root        while s:            if s[0] not in cur: cur[s[0]] = [ {} , 0 ]            cur[s[0]][1] += 1            cur = cur[s[0]][0]            s = s[1:]    def find(self, s)-&gt;int:        cur = self.root; pre_v = 0        while s:            if s[0] == '?': return pre_v            else:                if s[0] not in cur: return 0                pre_v = cur[s[0]][1]; cur = cur[s[0]][0]            s = s[1:]        return pre_vdef solution(words, queries):    prefix_dict = defaultdict(Trie)    suffix_dict = defaultdict(Trie)    len_dict = defaultdict(int)    result = []    for word in words:        prefix_dict[len(word)].insert(word)        suffix_dict[len(word)].insert(word[::-1])        len_dict[len(word)] += 1    for q in queries:        if q[0] == '?' and q[-1] == '?':            result.append(len_dict[len(q)])        elif q[-1] == '?': #preffix_query            result.append( prefix_dict[len(q)].find(q))        elif q[0] == '?': #suffix_query            result.append( suffix_dict[len(q)].find(q[::-1]) )        else:            print(\"IMPOSSIBLE\", q)    return result","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/13/search_lyrics.html"
      },{
        "title": "Trie: 구글 자동 완성의 비밀!",
        "excerpt":"혹시 검색어, 채팅 추천이 어떤 원리로 운영되는 지 궁금하신 적 있으신가요?현실적으로는 프론트, 백, 데이터 프로세싱 등의 다방면의 접근이 필요하지만그 중 백에서 사용 되는 모델은 트라이(Trie)를 기반으로 하는 것이 많습니다! 이는 트라이의 기능이 검색어를 효율적으로 찾는 것에 도움이 되기 떄문인데요.우리는 여기서 Basic 한 Trie에 간단히 대해서 알아보겠습니다.   ※ 현재 대부분 기업은 Basic이 아닌 훨씬 최적화, 변형된 트라이를 사용합니다. 트라이는 어떤 기능을 하나요? 트라이는 String-search, Substring-search 등을 수행합니다이 중 String-search 기능을 예로 설명하겠습니다.우리는 검색어 관리팀이고, n개 낱말의 리스트를 가지고 있다고 합시다.가진 리스트는 {‘한국은행’, ‘한국만세’, ‘일본’, ‘국장’, ‘국물’,…, ‘국뽕’} 이 때, 한 유저가 기존의 리스트에 ‘국뽕‘이라는 낱말이 있는 지가 궁금합니다.핵심: 어떻게 하면 리스트에서 이 낱말이 있는 지를 효율적으로 알 수 있을까요??※ 다음으로 넘어가기 전에 혼자 한 번 고민해봅시다! Brute-force 하게 해봅시다.  어렵게 생각하지 말고 리스트 안의 것 모두를 우리의 Query인 ‘국뽕’과 하나씩 비교합시다한국은행과 국뽕을 먼저 비교하고, 다음은 한국만세, 다음은 일본 … 등등 n-1번 까지 있던 모든 글자와는 틀렸다는 것을 확인하고 마지막에서 와서야 겨우‘국뽕’과 비교를 할 수 있게 되고, 우리는 ‘국뽕’이라는 낱말이 있다는 것을 발견합니다. 이를 시간 효율성에 비추어 생각하면 최악의 경우는 O(N*M)입니다.이 때, N = 리스트의 길이, M = 쿼리 낱말의 길이입니다.운좋게, 쿼리가 하나 일 경우에는 이 Brute-force 방법도 참아 줄만 합니다만 만약 궁금한 게 하나의 쿼리가 아니라, [‘국뽕’, ‘일본’, ‘나라’, ..] 처럼 K 개 쿼리의 리스트이면,각각 쿼리도 똑같은 과정을 거치기에 시간효율성은 O(N* M *K)가 될 것입니다.위의 시간 효율성은 굉장히 비효율적이며, 현실에서도 적용하기 어렵습니다.이것을 해결하기 위해서 아래와 같은 트라이(Trie)라는 구조가 고안되었습니다. 트라이의 구조 트라이의 아이디어는  낱말을 하나 하나 글자로 쪼개어 트리로 저장한다입니다.예를 들면 ‘한국은행’ -&gt; [‘한’, ‘국’, ‘은’, 행’], ‘일본’ -&gt; [‘일’, ‘본’]과 같이 모두 쪼갠 후에 아래와 같은 과정을 거쳐 트리 형태로 저장을 합니다. Trie를 만드는 단계:만드는 단계는 아래와 같은 두 가지 경우로 진행됩니다.   낱말을 글자로 쪼갠 후 노드에 공통되는 글자가 있으면 그 글자 노드로 진행  낱말을 글자로 쪼꺤 후 노드에 그 글자가 없다면, 글자에 해당되는 노드를 만들고 진행아래는 Trie를 만드는 과정 중 ‘한국만세’ 라는 낱말을 넣는 차례입니다.  아래는 Trie를 만드는 과정 중 ‘일본’ 이라는 낱말을 넣는 차례입니다.  Trie를 다 만든 단계:위의 과정이 모두 끝나면 아래와 같습니다.  Query를 찾는 단계:우리가 찾고싶은 쿼리는 ‘국뽕’이라고 한다면 먼저 ‘국‘을 가진 노드를 찾고‘국‘에 해당하는 다음 노드로 넘어간다음, ‘뽕‘이라는 노드를 찾으면 됩니다  이번에는 ‘일본’이라는 낱말을 찾는 경우입니다.  이번에는 ‘나라’ 라는 낱말을 찾는 경우인데, 첫 번째 노드부터, ‘나’ 라는 글자가존재하지 않습니다. 따라서 여기엔 ‘나라’ 라는 낱말는 없다 라는 걸 바로 알 수 있습니다  트라이의 장단점 장점:Query를 찾을 때, Brute-force를 이용하는 것보다 좋은 time-complexity를 가집니다.특히, 처리하는 Query의 수가 많아지면 질수록 이 구조은 정말 유용합니다. 구현하는 것도 어렵지 않고 아이디어도 간단해서 여러 응용을 하기 좋습니다.예로: Visted 같은 변수를 추가해서, 갯수를 추적하는 것도 가능합니다. 단점:space-complexity면에서는 기존의 것보다 비효율적입니다.대부분 구현과정에서 Map을 쓰게 되는데, 이 때 space가 꽤 듭니다. 쿼리가 워낙 적으면 오히려 시간이 걸릴 수도 있다.일단 이 구조는 만들 때도 String hash를 하기 때문에 시간이 걸립니다.따라서 쿼리 양은 되게 적고, 저장되어있는 단어는 상대적으로 많을 때오히려 Brute-force한 것보다도 더 안좋은 execution-time을 가질 수도 있습니다. 실제 구현 by Python 구현 아이디어:   linked-list  Dictionary  iteration  TreeCode: class Trie:    def __init__(self):        self.root = {}    def insert(self, s):        cur = self.root        while s:          if s[0] not in cur: cur[s[0]] = {}          cur = cur[s[0]]          s = s[1:]        cur[0] = {}    def find(self, s)-&gt;bool:        cur = self.root;        while s:            if s[0] not in cur: return False            cur = cur[s[0]]            s = s[1:]        if 0 in cur: return True        else: return False","categories": ["non-linear-ds","advanced-ds"],
        "tags": [],
        "url": "http://localhost:4000/non-linear-ds/advanced-ds/2020/04/14/Trie.html"
      },{
        "title": "카카오 테스트:블록 이동",
        "excerpt":"PS에서는 나오기 힘든 코딩을 요구합니다.카카오 Tech 측에서도, ‘상당한 난이도의 코딩을 요구한다.’ 라고 언급할 정도로보통 ProblemSolving 문제 이상의 상당한 구현력을 요구합니다. 핵심 개념:   BFS  HashMap  Memoization - visited풀이법:   최소 시간을 구하기 위해서 BFS을 이용한 Outer-loop에서 최소 시간인 time을 추적합니다. 마지막 칸을 만나게 되면 time을 Return 합니다.  경우의 수 가지치기를 위해, HashMap을 이용한 memoization을 활용해 이미 지났던 경로를 다시 지날 경우는 Queue에서 제외합니다.  이 때, HashMap 안에는 (좌표1, 좌표2) 가 하나의 키의 역할을 하며   - 조건1  rotate할 때, 문제 조건에 따르면, 축 (axis) 대각측 칸이 0임을 계속 추적해야 하는데, 이 점에서 저는 어떤 패턴도 발견하지 못해서 모든 경우에 맞게 하드코딩을 하였습니다.조건1이 필요한 이유:i.e; ((0,0), (0,1)) 와 ((0,1), (0,0)) 같은 건 같은 하나의 key로 취급을 해야하기 때문입니다. HardCoding 참고: style: 가로모양 or 세로모양, axis: 좌표1가 축 or 좌표2가 축, direction: 시계방향 or 반시계 방향 import osimport sysfrom collections import defaultdict# style|axis|direcitonValueArray = [[[None]*2 for i in range(2)] for i in range(2)]CheckArray = [[[None]*2 for i in range(2)] for i in range(2)]def check(coord1, coord2, board):    x1, y1 = coord1; x2, y2 = coord2    if min(x1, y1, x2, y2) &lt; 0: return False    elif max(x1, y1, x2, y2) &gt;= len(board): return False    elif board[x1][y1] == 1 or board[x2][y2] == 1: return False    else: return Truedef goNEWS(coord1, coord2, i):    move = [(-1,0), (0, 1), (0, -1), (1,0)]    new_coord1 = (coord1[0]+move[i][0], coord1[1]+move[i][1]); new_coord2 = (coord2[0]+move[i][0], coord2[1]+move[i][1])    return sorted((new_coord1, new_coord2))def rotate(coord1, coord2, board, axis, direction):    global ValueArray, CheckArray    axis_coord = coord1 if axis == 0 else coord2    style = 0 if coord2[1] &gt; coord1[1] else 1    Check = CheckArray[style][axis][direction]    Value = ValueArray[style][axis][direction]    Check_coord = (axis_coord[0] + Check[0], axis_coord[1]+Check[1])    if 0 &lt;= Check_coord[0] &lt; len(board) and 0 &lt;= Check_coord[1] &lt; len(board) and board[Check_coord[0]][Check_coord[1]] == 0:        return sorted( ( (axis_coord[0]+Value[0], axis_coord[1]+Value[1]), axis_coord) )    else:        return ((-1,-1), (-1,-1))def initialize(ValueArray, CheckArray):    CheckArray[0][0][0] = (-1,1);   ValueArray[0][0][0] = (-1,0)    CheckArray[0][0][1] = (1,1);    ValueArray[0][0][1] = (1,0)    CheckArray[0][1][0] = (-1,-1);  ValueArray[0][1][0] = (-1,0)    CheckArray[0][1][1] = (1,-1);   ValueArray[0][1][1] = (1,0)    CheckArray[1][0][0] = (1,1);    ValueArray[1][0][0] = (0,1)    CheckArray[1][0][1] = (1,-1);   ValueArray[1][0][1] = (0,-1)    CheckArray[1][1][0] = (-1,1);   ValueArray[1][1][0] = (0,1)    CheckArray[1][1][1] = (-1,-1);  ValueArray[1][1][1] = (0,-1)def solution(board):    global ValueArray, CheckArray    initialize(ValueArray, CheckArray)    HashMap = defaultdict(int)    Q = [( (0, 0), (0, 1) )]    time = 0    while True:        next_Q = []        while Q:            coord1, coord2 = Q.pop(0)            if not check(coord1, coord2, board): continue            if (coord1, coord2) in HashMap and HashMap[(coord1, coord2)] &lt;= time: continue            if coord2[0] == len(board)-1 and coord2[1] == len(board)-1: return time            HashMap[(coord1, coord2)] = time            for i in range(4):                next_Q.append(tuple(goNEWS(coord1, coord2, i)))            for axis in range(2):                for direction in range(2):                    next_Q.append(tuple(rotate(coord1, coord2, board, axis, direction)))        time += 1        Q = next_Q","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/15/move-block.html"
      },{
        "title": "BFS:카카오 지도 경로 찾기의 비밀!",
        "excerpt":"지도 앱을 이용해 최단 경로를 찾거나 주변에 가까운 음식점은 어떤 것이 있는지같은 기능들 한 번씩은 사용해 보셨죠. 어떤 원리가 있는 지 궁금하신 적 있나요?이 안에는 프론트, 백, 데이터프로세싱, GPS등 여러 기술이 복잡하게 있지만그 중 백에서는 BFS을 기반한 알고리즘이 쓰이는 경우가 많습니다.과연 BFS란 머고 어떤 기능으로 위 기능들을 할 수 있는지 알아보겠습니다. BFS는 어떤 기능을 하나요? BFS는 길찾기 또는 주변탐색 같은 노드탐색기능을 수행할 수 있습니다.비슷한 기능을 수행하는 알고리즘으론 DFS(depth first search)가 있습니다. BFS는 Breath-First-search의 약자로 너비-우선-탐색을 의미하는데요.너비를 우선 탐색하기 때문에, 가장 가까운 노드 탐색이나, 주변에 있는 노드를 탐색하는 경우는 DFS보다 좀 더 효율적이라는 장점을 가집니다! 이 중 ‘가장 가까운 노드 탐색’ 기능을 예와 함께 자세히 설명하겠습니다. 철수가 여행 중 배가 고파 짜장면을 먹을려고 하는데, 이 동네에는 3개의 중국집이 있습니다.철수는 너무 배가 고파서 현재 위치에서 가장 가까운 중국집에 가서 짜장면을 먹으려고 합니다.  위는 동네의 지도이고 철수는 어떻게 하면 효율적으로 가장 가까운 중국집을 찾을까요?※ 다음으로 넘어가기 전에 혼자 한 번 고민해봅시다! brute-force하게 해봅시다. 일단 철수 위치에서 갈 수 있는 모든 노드를 조사하고 그 노드가 중국집이라면그 거리 기록하고, 기록한 거리를 모두 비교해서 가까운 중국집을 알아내는 방법입니다.  위처럼 구하면, 이 동네에서 현 위치에서 가장 가까운 중국집은 황룡반점이다.라는 것을 알 수 있고, 철수는 현 위치에서 1M 떨어진 청룡반점으로 갈 것 입니다. 하지만 이는 모든 노드와 길을 가봐야지 최단 거리를 알 수 있다는 것이죠.만약 동네가 커질수록, 즉 Nodes와 edges가 많아질수록 굉장히 비효율적이 됩니다.이 때 time-complexity를 구해보면, O(N+M) 입니다.(이 떄, N = nodes의 수, M = Edges의 수 = 길의 수) 이 비효율성을 해결하기 위해서 BFS라는 알고리즘을 고안하게 되었습니다. BFS: BFS를 이용한 풀이법은 거리를 기준으로 Greedy하게 문제를 접근해서 푸는 것입니다.풀어 말하면, 가까운 거리의 노드부터 차례 차례 구하다 보면 가장 먼저 만난 노드가 정답이다.라는 아이디어인데, 먼저, 거리를 기준으로 노드를 구한다는 것을 설명하겠습니다. 거리를 기준으로 노드를 구하다는 것은 그림으로 표현하면 아래와 같습니다. 1번 경우: 먼저 거리가 1m인 Node들을 구하는 경우입니다.  2번 경우: 거리가 2m인 Node 들을 구하는 경우입니다.  3번 경우: 거리가 3m인 Node들을 구하는 경우입니다.  우리는 위의 BFS과정에서 약간의 직관을 사용하면 문제를 쉽게 풀 수 있습니다.바로 첫 번쨰의 경우만 진행하고 두 번쨰, 세 번째 경우는 생략한다.라는 것입니다.첫 번째 경우에서 중국집을 만나면, 그 중국집이 바로 가장 가까운 중국집입니다.이유는 다음 경우에서의 중국집들은 이 중국집보다 멀리 있을 수 밖에 없기 때문입니다. BFS의 장단점: 장점:위처럼 최단거리 노드를 탐색하는 경우에는 정말 특화되어있습니다.Time-complexity는 지도의 구성(Topology)에 따라 다르지만 기존의 O(N+M) 보다는훨씬 좋은 Time-complexity를 보유할 수 있습니다. 알고리즘이 간단하고 딴 곳에 쓰기도 좋아서 다른 알고리즘에도 자주 쓰이기 좋습니다.대표적으로 다익스트라 알고리즘, Kruaskal 알고리즘에서 BFS를 이용합니다. 단점:경우에 따라 BFS를 썻을 때 논리 구조가 복잡해지고 구현하기 쉽지 않을 수 있습니다.이는 BFS가 각 Node별로 Parallize하게 진행되기 때문입니다.※ Parallel programming을 할 수 있기 때문에, 장점으로 될 수 있겠네요 실제 구현 by Python import osimport sysfrom collections import defaultdictdef BFS(nodes, edges):  #make edges list  adj_list = defaultdict(list)  for edge in edges:    node1, node2 = edge    adj_list[node1].append(node2)    adj_list[node2].append(node1)  #bfs  Q = []; Q.append('철수 위치')  visited = set()  while Q:    cur_node = Q.pop(0)    if cur_node in visited: continue    visited.add(cur_node)    if cur_node[-2:] == '반점': return cur_node # 중국집    for next_node in adj_list[cur_node]: Q.append(next_node)","categories": ["graph-theory","basic-algo"],
        "tags": [],
        "url": "http://localhost:4000/graph-theory/basic-algo/2020/04/16/bfs.html"
      },{
        "title": "Matrix-roatation:PPT에서의 그림 90도 회전의 비밀!",
        "excerpt":"PPT를 만들거나 포토샵을 수정할 때, 그림을 시계방향 또는 반시계방향으로90도, 180도, 270도 회전을 하신 적이 있으신가요?  우리는 마우스를 이용해 돌리지만,컴퓨터 안에서는 어떤 일이 벌어지고 있을까요?답부터 말하자면, 컴퓨터는 Matrix-rotation을 이용해 그림을 90도 회전합니다.이 Matrix-rotation에 대해서 간단히 알아보도록 하겠습니다.   참조- 여기서는 Inplace가 아닌 Extra memory를 쓴 matrix-rotation에 대한 설명입니다. 그림파일은 무엇인가? 주제에 들어가기 앞서서, 그림파일 이란 무엇인지 아셔야합니다. 정말 간단하게 컴퓨터는 그림파일을 어떻게 인식하고 있는지 설명하겠습니다.  정말 간단하게 설명하면, 위 그림처럼 각 그림은 작은 Pixel들로 이루어져 있고각 Pixel들은 숫자의 행렬(Maxtrix) 형태로 구성되어 있습니다!이 말은 결국 모든 그림은 큰 숫자의 행렬(Matrix)모양으로 존재하고 있다는 것입니다. 그럼, 그림을 회전 시킨다는 건?  결국 그림을 회전시킨다는 것은 다시 그림을 만드는 데그 그림은 본래 그림의 행렬 원소를 적당한 패턴으로 재배열하여 만든 행렬입니다. 시계방향으로 90도로 회전  위와 같이 시계방향일 때, 행렬도 똑같이 90도를 회전시킨다고 상상하고 돌리면행렬로 생각했을 때는 행렬의 좌표는 아래와 같은 패턴을 따른다는 것을 알 수 있습니다.  패턴에 따르면, 행렬 좌표로 생각했을 때 새로운 행렬의 x좌표 = 기존의 y좌표이고새로운 행렬의 y좌표 = 행렬의 크기 - 기존의 x좌표 - 1 입니다. 구현 by Python def Clockwise(matrix):    new_matrix = [[0]*len(matrix) for i in range(len(matrix))]    for i in range(len(matrix)):        for j in range(len(matrix)):            new_matrix[j][len(matrix) - i - 1] = matrix[i][j]    return new_matrix반시계방향으로 90도로 회전  위와 같이 반시계방향일 때, 행렬도 똑같이 90도를 회전시킨다고 상상하고 돌리면행렬로 생각했을 때는 행렬의 좌표는 아래와 같은 패턴을 따른다는 것을 알 수 있습니다.  패턴에 따르면, 새로운 행렬의 x좌표 = 행렬의 크기 - 기존의 y좌표 - 1 이고새로운 행렬의 y좌표 = 기존의 x좌표 입니다. 구현 by Python def Counterclockwise(matrix):    new_matrix = [[0]*len(matrix) for i in range(len(matrix))]    for i in range(len(matrix)):        for j in range(len(matrix)):            new_matrix[len(matrix)- 1 - j][i] = matrix[i][j]    return new_matrix  돌리고자 하는 각도가 180, 270일 떄는?이미 아시겠지만, 위의 과정들을 연속해서 하면 됩니다. ","categories": ["misc","basic-algo"],
        "tags": [],
        "url": "http://localhost:4000/misc/basic-algo/2020/04/17/matrix-rotation.html"
      },{
        "title": "HashTable:휴대폰의 연락처 찾기의 비밀!",
        "excerpt":"휴대폰에서 전화번호 검색을 위해 상대방의 이름을 쳐서 검색한 적이 있으신가요?이 때, 내부에는 효율적인 검색을 위해 HashTable 를 이용하여 전화번호를 찾습니다.이 글에선 과연 HashTable는 무엇인지, 어떤 원리가 숨어있는 지를 알아보겠습니다.   참조: HashTable은 기본적인 DS로 다른 알고리즘이나 DS에 정말 많이 쓰입니다. HashTable은 어떤 기능을 하나요? 어떤 값을 빠른 시간에 Search하거나 값을 Update를 할 수 있는 자료 구조입니다.자세히 이야기하면, 키(key)를 통해 얻고자 하는 값에 접근 하는 자료구조입니다. 여러 기능 중 HashTable의 Search의 효율을 예와 함께 설명을 드리겠습니다. 문제 제시: 한 시골 학교에 6명의 학생이 있는 반과 그 반의 선생님이 있습니다.어제 수학 시험을 쳤고 선생님은 각 학생의 수학 점수 기록을 가지고 있습니다.이 중 ‘재석’이라는 학생이 자신의 수학점수가 궁금해서 선생님을 찾아 왔습니다.  위는 수학점수 기록이고, 선생님은 어떻게 효율적으로 ‘재석’의 수학 점수를 알 수 있을까요?※스스로 한 번 방법을 생각해봅시다! Brute-force하게 해봅시다. 단순하게 위에서부터 학생의 이름을 한 명씩 비교해서 찾을 수 있습니다.그 과정은 아래와 같습니다.  우리가 찾고 싶은 건 ‘재석’ 학생이지만 데이터의 첫 번째 칸은 ‘동훈’ 학생입니다.따라서 다음으로 넘어갑니다.  위의 경우에도 ‘재석’ 학생의 데이터가 아닙니다.이처럼 이름이 찾는 이름이 아닐 경우에는 계속 다음 데이터로 넘어갑니다.  마지막에 비로소 재석의 이름에 해당하는 데이터를 찾았습니다. 하지만 위 방법으로 진행했을 경우, 최악의 경우 처음부터 모든 데이터를 검사해야 합니다.심지어 왼쪽처럼 이름을 비교하는 상황에도 시간 cost가 발생합니다. 찾는 과정은 Time-complexity를 보았을 때, 최악의 경우는 O(N*M)입니다.(이 때 N = 학생 수, M = 학생 이름의 길이) 더 나아가, ‘재석’ 뿐 아니라 다른 학생들도 수학 점수가 궁금해서 찾아오면 어떡할까요?매 학생이 물을 때마다, 모든 데이터를 체크해야 하고, 이건 굉장히 비효율적입니다.만약 K명의 학생이 물어본다고 가정하면 시간 소모는 O(N*M *K)가 됩니다. 따라서 물어보는 학생이 많으면 많을 수록 소모되는 시간은 기하급수적으로 커집니다.이 비효율성을 줄이고자, 다음과 같은 HashTable이라는 자료구조가 고안되었습니다. HashTable: 이 문제를 해결하는 아이디어는 Hashing와 Dynamic-array의 마법을 이용하는 것입니다.사실, 이 두 가지의 비밀 뒤에는 수학, 통계, LUT 등 여러가지 고려할 것이 많습니다.하지만, 이 글에서는 HashTable의 전체적인 구조에 관해서만 간단히 알아보겠습니다.    -참조 Dynamic-array의 마법을 알고 싶으면 Dynamic-array-참조 Hashing의 마법을 알고 싶으면 Hashing 전체적인 구조:※ 쉬운 이해를 위해, 몇 개의 전제 조건을 설정하겠습니다.   10개 slots의 slots-list로 시작  사용자 임의의 한글-LUT(lookupTable)  사용자 임의의 String-Hash 함수  Birthday-Paradox는 신경 쓰지 않음  잘못된 Hashing 함수로 인한 Duplicate-key는 신경 쓰지 않음초기의 HashTable: 위는 아직 아무런 Key와 데이터가 없는 초기의 HashTable을 만든 모습입니다.HashTable은 Keys - Hash - slots의 구조로 이루어져 있다고 생각하면 됩니다.slots은 초기 사이즈가 10인 Dynamic-array로 되어있습니다.Hashing 함수는 다음과 같은 두 단계로 이루어져있습니다.   String의 각 글자의 값을 합칩니다.  합친 값을 slots의 갯수로 %(Modulo)를 합니다.Key를 받으면, Hashing이 Key를 Slots의 알맞은 index의 값으로 바꾸어 줍니다.오른쪽은 임의의 한글-LUT로 Hashing의 값을 구할 때 도와줍니다. HashTable 데이터를 넣는 과정: 아래는 ‘동훈’의 데이터를 넣는 과정입니다.  데이터를 넣는 과정은 크게 5단계로 이루어 집니다.   ‘동훈’ 학생의 이름이 Key로 들어갑니다.  ‘동훈’ 각각 ‘동’, ‘훈’에 해당하는 Decimal 값을 LUT에서 찾습니다.  LUT에서 찾은 값을 이용해 Hash-function에서 두 가지 단계로 처리합니다.  나온 값 3에 해당하는 Index를 가진 slot에 접근합니다.  해당하는 index의 slot에 ‘동훈’의 점수인 15를 넣습니다.아래는 ‘명수’의 데이터를 넣는 과정입니다.  HashTable에 데이터를 다 넣은 상태: 아래는 모든 학생의 데이터를 다 넣고 난 후 HashTable의 모습입니다.  HashTable 데이터를 찾는 과정: 아래는 ‘재석’ 학생의 데이터를 찾는 과정입니다.  데이터를 찾는 과정은 데이터를 넣을 때의 과정과 비슷합니다.   Hash-func을 통해서 ‘재석’의 Index 값인 4를 찾는다.  index가 4인 slot에 접근한다.  index가 4인 slot에 저장된 데이터인 ‘100’을 도출한다.아래는 Keys에 없는 ‘홍철’ 학생의 데이터를 찾는 과정입니다.  만약 기존의 키에 없었던 ‘홍철’이라는 학생 데이터를 찾으려고 하면위처럼 Hash-func에 의해 index가 1인 slots에 접근하게됩니다.하지만, index가 1인 slot에는 데이터가 없고 따라서 Null을 Return 합니다.   실제론, Birthday-paradox 같은 문제로 Collision이란 것이 생깁니다.대처하기 위한 전략으론 Open-address나 separate-channing 등 몇 가지가 있습니다.더 자세히 알아보기 HashTable의 평가: 일단 data를 Insert할 떄는 brute-force 방법보다 더 걸릴 수 밖에 없습니다.각 데이터는 Hashing을 거쳐 저장되기 때문에 Hashing 하는 시간만큼 더 걸리는 것이죠. Big-O notation으로 따지면, O(N*M)의 시간이 걸립니다.(이 때, N = 넣고자 하는 학생 수, M = 각 학생의 이름 길이)넣을 때의 시점에선 이전 방법보다 효율성이 좋다고는 하기 어려울 거 같습니다. 하지만, 물어보는 학생의 경우, 즉 쿼리를 처리할 때는 이전보다 훨씬 좋습니다.이전에는 매번 가지고 있던 모든 데이터를 체크해야 했지만 이번에는 그렇지 않습니다.각 학생은 자신의 이름을 Hash-func에만 넣기만 하면 바로 Index를 얻을 수 있습니다.이 때 얻은 Index의 slot은 Dynamic-array의 마법으로 바로 접근할 수 있습니다. Big-O notation으로 보면, O(K*M)의 시간이 걸립니다.(이 때, K = Query의 수, M = 각 Query 학생의 이름 길이)이 시간이 걸리는 이유는 각 Query들은 Hash-func 과정을 해야하기 때문에 어쩔 수 없이Hashing에 걸리는 시간인 O(M)을 소모할 수 밖에 없습니다. 하지만 Search하는 시간은O(1)으로 Linear하게 바로 원하는 값에 접근할 수 있습니다.따라서, 이전보다 훨씬 좋은 Query 처리 속도를 가진다고 할 수 있습니다. HashTable과 관련된 용어: 구현 언어에 따라 또는 구현 방법에 따라 또는 잠깐 언급한 Collision 전략에 따라관련 용어들은 조금씩 다릅니다. 자주 쓰이는 것들로 HashMap, Map, Dictionary가 있습니다.하지만 핵심은 Key-Value로 pair이 된 Collection이라는 것에서 같습니다. 참고로, Python에서는 Dictionary, Set이 대표적인 HashTable로 구현된 DataType입니다.   Python에서는 Set이 Value가 Binary인 HashTable로 되어있습니다. 실제 구현 by Python 구현 아이디어:   Dynamic-array  HashCode: import osimport sys# 한글-LUTLUT = {'동': 1, '훈': 2, '명': 3, '수': 4        '형': 5, '돈': 6, '준': 7, '하': 8        '광': 9, '희': 10, '재': 11, '석': 13        '홍': 14, '철': 17}class HashTable:  def __init__(self):    self.Num_of_Slots = 10    self.slots = [None]*10 # dynamic array  # Hash-fun  def _hash(self, name):      global LUT      index = 0      #proc-1      for chr in name:        index += LUT[chr]      #proc-2      index %= self.Num_of_Slots      return index  def insert(self, name, data):    index = self._hash(name)    self.slots[index] = data  def search(self, name):    index = self._hash(name)    value = self.slots[index]    if value: # if it is not None      return value    else:      return None","categories": ["non-linear-ds","basic-ds"],
        "tags": [],
        "url": "http://localhost:4000/non-linear-ds/basic-ds/2020/04/17/Hashtable.html"
      },{
        "title": "카카오 테스트: 외벽 점검",
        "excerpt":"핵심 개념   Complete search  greedy  manage circular case  permutations변수 (1) 몇 명의 친구를 고르는지(2) 어떤 값을 가진 친구들을 고르는 지(3) 고른 친구들은 어떤 순서로 진행하는 지(4) 친구는 각각 어떤 weak 지점부터 시작해야 하는지(5) 친구는 각각 어떤 방향&lt;시계방향, 반시계&gt; 으로 진행해야하는지 풀이법 일단 전체적으로는 Complete Search 문제 입니다.dict와 weak 길이가 충분히 작기 때문에 완전 탐색방법도 Reasonable 하다고 볼 수 있고모든 변수가 독립적으로 결과에 영향을 끼치기 때문에, 최악의 경우 모든 경우의 수를 구해서 대조를 해봐야 합니다. 중복을 최대한 없애고, Greedy한 접근으로 경우의 수 가지치기 하기최악의 경우 모든 경우의 수를 봐야하지만, 우리는 고른 인원의 최솟값만 구하면 되고(greedy)전체적으로 weak가 circular case 라는 것을 집중하면 상당 수의 중복 되는 경우의 수를 가지치기 할 수 있습니다. 먼저, greedy로 가지치기 할 수 있는 부분은 변수 (1)과 (2)입니다.(1)은 outer-loop로 두고 i를 1부터 시작해서, 조건을 만족하는 할 때, 바로 return하게 합니다.(2)은 처음부터 dict를 내림차순으로 지정하여 가장 멀리 갈 수 있는 친구부터 배정합니다. 두 번째, 전체적으로 weak는 둘레가 n인 circular 구조 위에 있습니다.이것을 이용해, (4)과 (5)을 한꺼번에 고려할 수 있습니다. 차례대로 시작 부분을 하나 지정하고, 그 시작을 기준으로 왼쪽과 오른쪽 파트로 나누어서 왼쪽파트는 n값을 플러스 하면 됩니다.Ex) n= 12일떄, [1,5,6,10] -&gt; 5선택 -&gt; [5, 6, 10, 13] , [1,5,6,10] -&gt; 6선택 -&gt; [6, 10, 13, 17] 위의 예처럼 하면 시작지점과 진행방향을 모두 커버할 수 있고(혹시 의심가시면 종이에 몇 가지 예 적어보시면 같은 결과가 나옵니다.)이것은 circular 구조를 고려하지 않아서 모든 weak에 2가지 방향성을 주는 경우에 비해비교 해야할 경우의 수 숫자가 2**n -&gt; n으로 줄어들게 됩니다. 마지막으로 변수 (3)은 어떠한 방식으로도 가지치기를 할 수 없어서 itertools에서 사용하시거나, user-defined로 permutation를 구현하셔서완전탐색을 끝내시면 될 거 같습니다. 구현 by Python import sysimport osdef permutation(candidates, Prepermuation, res):    if len(candidates) == 0: res.append(Prepermuation); return    else:        for i in range(len(candidates)):            permutation(candidates[:i]+candidates[i+1:], Prepermuation + [ candidates[i] ], res)        returndef solution(n, weak, dist):    # complete search    dist.sort(reverse = True)    for i in range(1, len(dist)+1):        permutations = []; permutation(dist[:i], [], permutations)        for p in permutations:            for start in range(len(weak)):                _left = weak[:start]; _right = weak[start:]                traverse_list = _right + [x+n for x in _left]; candidate = p.copy()                while traverse_list and candidate:                    cur = traverse_list.pop(0); d = candidate.pop(0);                    Cover = cur + d                    while traverse_list and traverse_list[0] &lt;= Cover: traverse_list.pop(0)                if not traverse_list:                    return i    return -1","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/17/wall.html"
      },{
        "title": "BitMask:Bit 인원보고 하겠습니다!",
        "excerpt":"우리가 군대의 점호시간에 현재 부대원을 보고함으로서, 현재 상태를 나타내듯이프로그램을 구현 하는 과정 중, 많은 부분에서 현재 상태를 체크하고 보고하는 일이많습니다. Bit를 이용한 BitMask로 상태를 표시하면 효율적일 때가 많습니다.이 글에서는 BitMask가 무엇인지? 어떻게 쓰이는 지에 대해서 알아보겠습니다. Bit의 마법: 많은 분들이 이미 아는 것처럼, 컴퓨터는 모든 것이 이진법으로 이루어져 있습니다.10(decimal) = 1010(bin), 4(decimal) = 10(bin), 13(decimal) = 1101(bin)처럼숫자의 경우, 컴퓨터는 우리의 십진법 숫자를 이진법 숫자로 바꾸어 해석합니다.  위 같은 사실은 우리가 “오호 2진법이군!”만 하고 넘어갈 것이 아니라우리의 알고리즘에도 이 Bit성질을 적용할 수 있고 실제 구현에서도 자주 이용합니다.BitMask란 ‘bit를 이용해 우리의 얼굴(mask)처럼 현재 상태를 표현한다.‘로 이해하면 됩니다.아래에서는 이 bit 성질을 이용한 BitMask의 기능에 대해서 알아보겠습니다.   ALU의 회로나 CPU구조를 아신다면 더 깊은 이해가 됩니다. 어떤 기능을 할 수 있는가? BitMask는 현재 상태를 표현, 변형 또는 비교 등의 기능을 수행 할 수 있습니다.이 상태를 변형하거나 비교는 Bitwise함수를 이용하게 되는 경우가 많습니다. Bitwise함수를 이용하는 이유는 이 함수들은 ALU 안의 OR 또는 AND Gate 등을 활용해각 bit 단위 연산을 CPU에서 한 번에 계산하여, 효율성을 훨씬 높일 수 있기 때문입니다.   BitWise 함수 알아보기 BitMask의 기능들은 아래의 문제와 함께 설명을 하겠습니다. 문제 제시 한 반에 학생 세 명이 있습니다. 어느 날 이 반에서 깜짝 조별 시험을 치기로 하였습니다.시험에서 요구하는 건 ‘국영수사과’ 로 5개 과목이고, 오픈북 시험을 치기로 하였습니다.시험은 쉬워서, 교과서만 있다면 학생은 과목에 해당되는 문제는 다 맞을 수 있습니다.하지만 어떤 과목에 해당되는 교과서가 없다면 학생은 틀리게 될 것 입니다.최대 두 명까지 조를 짤수 있습니다.  위는 학생들의 가방과 가방 안에 있는 교과서들입니다.어떤 학생과 어떤 학생이 조를 짜야지 무조건 백점을 맞는 조가 나올 수 있을까요?어떻게 하면 위의 답을 효율적으로 구할 수 있을까요? 주먹구구식 방법: 가장 쉬운 방법으로는 만들 수 있는 모든 조를 짜보고 조건이 맞는 지 확인하는 것입니다.조건이 맞다는 것은 각각 만든 조가 모든 교과서를 가지고 있는 지를 확인하는 것입니다. 확인 하는 방법은 조원의 가방 안에 교과서들을 다 모아놓고 하나씩 체크하는 것입니다.요약하면 문제 푸는 과정은 아래의 두 과정입니다.   랜덤하게 두 학생을 뽑아서 그룹을 만든다.  만든 그룹 안의 책들을 모아서 체크하고, 모든 종류의 책이 있는지 확인한다.문제를 푸는 일련의 과정은 아래와 같습니다.   학생1과 학생 2과 그룹을 이루는 경우위처럼 그룹을 만들고, 만든 그룹의 책들을 모두 모아 체크하면 아래와 같습니다.  체크 결과는 사회책이 없어서 이 그룹은 백점을 맞기 힘든 그룹이라는 결과가 나옵니다.따라서 다른 그룹을 만들고 위처럼 체크를 합니다.   학생2와 학생 3이 그룹을 이루는 경우위처럼 그룹을 만들고, 만든 그룹의 책들을 모두 모아 체크하면 아래와 같습니다.  체크 결과는 과학책이 없어서 이 그룹은 백점을 맞기 힘든 그룹이라는 결과가 나옵니다.따라서 다른 그룹을 만들고 위처럼 체크를 합니다.   학생1과 학생 3이 그룹을 이루는 경우위처럼 그룹을 만들고, 만든 그룹의 책들을 모두 모아 체크하면 아래와 같습니다.  체크 결과는 모든 교과서가 있어서 백점을 맞을 수 있는 그룹이다라는 결과가 나옵니다.따라서 그룹을 만드는 것을 멈추고 학생1-학생3 그룹이라는 답을 구할 수 있습니다. 평가:최악의 경우, 그룹 짜는 모든 경우의 수를 고려하는 것은 피할 수 없습니다.따라서 그룹을 만드는 시간 효율성은 O( (N*N-1)/2 )입니다.(이 때, N = 학생의 수 이고 위 식은 N개에서 2개를 뽑는 경우와 같습니다.) 그룹을 만드는 것뿐만 아니라, 매번 그룹의 교과서를 모아서 체크도 해야 합니다.이 경우의 수는 O(2 * M) (이 떄, M = 학생 가방 안에 있는 교과서 수)입니다.따라서 위 값들을 곱해서 나온 전체 시간효율성은 O((N * N-1)* M)입니다. 위 두 가지 과정 중 교과서를 다 모아서 검사하는 과정은 BitMasks와Bitwise 함수들을 이용하면 이전보다 훨씬 효율적으로 수행할 수 있습니다. BitMask 위 문제에서 BitMask의 아이디어는 다음과 같습니다.학생의 가방 상태를 5개의 bit로 생각하고, 각 bit는 책의 유/무를 알려주면 되지 않을까?이 아이디어는 그림으로 표현하면 아래와 같습니다.  위 아이디어를 이용해서 각각 학생들의 가방의 책 상태를 표시하면 아래와 같습니다.※ 괄호 안의 값은 십진법으로 나타낸 수 입니다.  위처럼 bitmask를 이용하면 각 학생의 가방 상태를 5개의 bit로 나타낼 수 있습니다.또한, 그룹을 만든 후의 그룹의 책의 상태는 OR을 이용하면 쉽게 구할 수 있습니다.※ 백 점을 맞는 조는 모든 책이 있는 상태로, Bitmask로 나타내면 ‘11111’입니다. BitMask를 이용한 풀이의 일련의 과정은 아래와 같습니다.   학생 1과 학생 2가 그룹을 이루는 경우위 그룹의 책 상태는 ‘11101’으로 4번째 bit가 나타내는 사회책이 없어 답이 될 수 없습니다.따라서 다른 그룹을 만들고 위처럼 체크를 합니다.   학생 2와 학생 3이 그룹을 이루는 경우위 그룹의 책 상태는 ‘11110’으로 5번째 bit가 나타내는 과학책이 없어 답이 될 수 없습니다.따라서 다른 그룹을 만들고 위처럼 체크를 합니다.   학생 1와 학생 3이 그룹을 이루는 경우위 그룹의 책 상태는 ‘11111’, 즉 모든 책이 있는 상태이고 따라서 우리가 찾는 답입니다.따라서 다른 그룹을 만드는 걸 멈추고 답을 도출합니다. BitMask 평가: 처음의 주먹구구식 방법과는 다르게 data-preprocessing 시간이 걸립니다.이유는 기존의 list 형태로 받은 책들을 가방의 bitMask로 바꿔야 하기 때문이죠. 하지만 그 후에 그룹의 상태를 얻을 때는 이전에 O(2 * M)의 시간이 걸렸던 것과다르게, O(1)로 가능합니다. Or operater을 사용해서 모든 책 유무를 한 번에비교하고 그룹의 상태를 얻는 것이 가능하기 때문입니다. 전체 시간효율성은 모든 그룹을 만드는 경우인 O((N * N-1)/ 2)입니다. 한계점:이 문제처럼 유/무 처럼 0과 1로만 상태 표현이 가능하면 BitMask가 효과적입니다.그러나 만약 ‘책은 있지만 반이 찢어진 상태’, ‘책은 있지만 1/4만 있는 상태’처럼0과 1로 책의 상태를 설명하지 못하는 경우가 있다면, 조금 복잡해 집니다. 이를 해결하기 위해 n개의 bit를 하나로 묶어 책 상태를 표현할 수 있습니다.하지만, 고려 해야할 상태가 많은 경우에는 이 과정에서 비효율성이 일어날 수 있습니다. 구현 by Python import osimport sysdef makeBitMask(student): # Bitmask 만들기  bitmask = 0  if '국어' in student: bitmask |= (1&lt;&lt;4)  if '영어' in student: bitmask |= (1&lt;&lt;3)  if '수학' in student: bitmask |= (1&lt;&lt;2)  if '사회' in student: bitmask |= (1&lt;&lt;1)  if '과학' in student: bitmask |= (1&lt;&lt;0)  return bitmaskdef solve(student_list): # 문제 풀이  bitmask_list = []  for student in student_list: bitmask_list.append(makeBitMask(student)) #data-PreProcessing  for i in range(len(bitmask_list)): #그룹 만들고 비교    for j in range(i+1, len(bitmask_list)):      if bitmask_list[i]|bitmask_list[j] == (1&lt;&lt;5) - 1:        return (i, j) # 답 도출","categories": ["misc","basic-algo"],
        "tags": [],
        "url": "http://localhost:4000/misc/basic-algo/2020/04/20/bit-mask.html"
      },{
        "title": "카카오 테스트:기둥과 보 설치",
        "excerpt":"이 문제는 문제의 효율성 고려나 어려운 개념을 요구하는 게 아니라주어진 복잡한 instructions을 코드로 구현 할 수 있는 지를 묻는 문제입니다.따라서 전체과정을 도식화하는 능력과 깔끔한 코드를 짜는게 핵심이라고 생각합니다. 핵심 개념:   Matrix rotation  BitMaskTIP: 첫 번째, 적당한 Matrix rotation를 이용해서 문제에서 주어지는 Matrix의 좌표를우리가 평소에 사용하는 Matrix의 좌표로 바꾸어 놓고, 문제를 생각하면 좀 더 수월합니다.몇 가지의 경우를 종이에 적어보시면, 어떻게 치환 할 지 패턴이 보이실 겁니다.Ex) n = 5일떄, (0,0) -&gt; (5,0), (0,3) -&gt; (2, 0), (3,4) -&gt; (1, 3)※ 앞: 문제에서 주어진 좌표, 뒤: 우리가 실제 사용할 좌표 두 번째, Bit maninpuation을 이용하면, 설치, 삭제 또는 현재 상태까지 나타낼 수 있습니다.OR: 설치, XOR: 삭제, xxxx: 앞에 두 개의 digit은 기둥의 상태, 뒤에 두 개의 digits은 보의 상태1: 있다 0: 없다로 생각하고 아래와 같이 생각하면 편합니다.Ex) 0000: 아무것도 없다, 1000: 기둥 아랫부분만 있다. ,1100: 기둥 아랫부분 과 기둥 윗부분이 있다.1011: 기둥 아랫부분 과 보의 왼쪽과 보의 오른쪽이 있다., 0001: 보의 오른쪽만 있다. 마지막으로, 이 문제는, 설치보단 삭제 부분이 조금 까다롭습니다.혹시 테스트가 13번 이후로 다 틀린다면, 삭제 부분에서 문제가 있을 확률이 큽니다. 풀이법 저 같은 경우 이걸 아래와 같은 과정을 도식화하여 풀었습니다.워낙 코드가 길어, 제 코드 리딩은 도움이 안될 거 같습니다.   삭제할 좌표에 실제로 보 또는 기둥이 존재하는 지 판단 (없을시 return)  일단 삭제한다고 가정  영향을 끼칠 좌표들의 유효성 검사  영향을 끼칠 좌표들이 모두 유효하다면 삭제 그대로 진행  하나라도 유효하지 않으면, 다시 삭제했던 구조물 재설치구현 by Python import osimport sysdef pillar_alive(coord, matrix):    x, y = coord    pillar_start, pillar_end, bar_start, bar_end = Checker(matrix[x][y])    if pillar_end or bar_start or bar_end: return True    else: return Falsedef bar_alive(coord, matrix, ttype):    x, y = coord    C_pillar_start, C_pillar_end, C_bar_start, C_bar_end = Checker(matrix[x][y])    if ttype == 'left':        L_pillar_start, L_pillar_end, L_bar_start, L_bar_end = Checker(matrix[x][y-1])        if C_pillar_end or L_pillar_end: return True        elif C_bar_start and L_bar_end: return True        else: return False    elif ttype == 'right': # given is start        R_pillar_start, R_pillar_end, R_bar_start, R_bar_end = Checker(matrix[x][y+1])        if C_pillar_end or R_pillar_end: return True        elif C_bar_end and R_bar_start: return True        else: return False    else:        print('IMPOSSIBLE')def Checker(value) -&gt; list:    #result = [pillar's start, pillar's end, bar's start, bar's end]    _bit = '{:04b}'.format(value)    result = []    for _ in _bit:        if _ == '0': result.append(False)        elif _ == '1': result.append(True)        else: print(\"Impossible: \", _)    return resultdef CoordSwapper1(coord, matrix): # problemSetting coord -&gt; build_it coord    x, y = coord    swapped_x = len(matrix) - 1 - y    swapped_y = x    return (swapped_x, swapped_y)def CoordSwapper2(coord, matrix): # built_in coord -&gt; problemSetting coord    x, y = coord    swapped_x = y    swapped_y = len(matrix) - 1 - x    return (swapped_x, swapped_y)def remove_bar(coord, matrix):    x, y = coord    L_pillar_start, L_pillar_end, L_bar_start, L_bar_end = Checker(matrix[x][y])    R_pillar_start, R_pillar_end, R_bar_start, R_bar_end = Checker(matrix[x][y+1])    if not L_bar_start: return    #remove    matrix[x][y]^= 2; matrix[x][y+1]^= 1    L_pillar_TEST = True if (not L_pillar_start) or pillar_alive((x,y), matrix) else False    R_pillar_TEST = True if (not R_pillar_start) or pillar_alive((x, y+1), matrix) else False    L_bar_TEST = True if (not L_bar_end) or bar_alive((x, y), matrix, 'left') else False    R_bar_TEST = True if (not R_bar_start) or bar_alive((x, y+1), matrix, 'right') else False    if L_pillar_TEST and R_pillar_TEST and L_bar_TEST and R_bar_TEST: return    else: matrix[x][y]|= 2; matrix[x][y+1]|= 1 #reinstalldef remove_pillar(coord, matrix):    x, y = coord    D_pillar_start, D_pillar_end, D_bar_start, D_bar_end = Checker(matrix[x][y])    U_pillar_start, U_pillar_end, U_bar_start, U_bar_end = Checker(matrix[x-1][y])    if not D_pillar_start: return    #remove    matrix[x][y]^= 8; matrix[x-1][y]^= 4    U_pillar_TEST = True if (not U_pillar_start) or pillar_alive((x-1, y), matrix) else False    L_bar_TEST = True if (not U_bar_end) or bar_alive((x-1, y), matrix, 'left') else False    R_bar_TEST = True if (not U_bar_start) or bar_alive((x-1, y), matrix, 'right') else False    if U_pillar_TEST and L_bar_TEST and R_bar_TEST: return    else: matrix[x][y]|= 8; matrix[x-1][y]|= 4 # reinstalldef install_pillar(coord, matrix):    x, y = coord    pillar_start, pillar_end, bar_start, bar_end = Checker(matrix[x][y])    if x == len(matrix)-1 or bar_start or bar_end or pillar_end:        matrix[x][y] |= 8        matrix[x-1][y] |= 4def install_bar(coord, matrix):    x, y = coord    L_pillar_start, L_pillar_end, L_bar_start, L_bar_end = Checker(matrix[x][y])    R_pillar_start, R_pillar_end, R_bar_start, R_bar_end = Checker(matrix[x][y+1])    if L_pillar_end or R_pillar_end or (L_bar_end and R_bar_start):        matrix[x][y] |= 2        matrix[x][y+1] |= 1def show_all(matrix, res):    n = len(matrix)    for x in range(n):        for y in range(n):            pillar_start, pillar_end, bar_start, bar_end = Checker(matrix[x][y])            _x, _y = CoordSwapper2( (x, y), matrix)            if pillar_start: res.append([_x,_y,0])            if bar_start: res.append([_x,_y,1])    returndef solution(n, build_frame):    res = []; matrix = [[0]*(n+1) for i in range(n+1)]    for op in build_frame:        x, y, a, b = op        _x, _y = CoordSwapper1((x,y), matrix)        if a == 0 and b == 0: remove_pillar((_x,_y), matrix)        elif a == 0 and b == 1: install_pillar((_x,_y), matrix)        elif a == 1 and b == 0: remove_bar((_x,_y), matrix)        elif a == 1 and b == 1: install_bar((_x,_y), matrix)        else: print(\"IMPOSSIBLE: \", op)    show_all(matrix, res)    res.sort()    return res","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/20/pillar.html"
      },{
        "title": "Dynamic Array: Array구조의 기본",
        "excerpt":"Dynamic-Array의 기능 Dynamic Array는 아래의 기능들을 수행할 수 있어야 합니다.   Initialize  Insert  Read  Update  Delete  ResizeInitialize DynamicArray는 내부 attribute로 할당받은 Heap 주소와 capcity, size를 가집니다.가장 처음에는 자료형*Capacity 만큼의 heap을 할당받아야 합니다.이 때, 내부적으로는 요청하는 크기만큼 Heap의 연속적인 배열을 할당을 해줍니다. Insert Dynamic array에서의 Insert는 두 가지 경우로 나눌 수 있습니다.&lt;1&gt; Array의 끝 부분에 Inert하는 경우 &lt;2&gt; Array의 중간부분에 Insert 하는 경우 1번의 경우에는 size를 1만큼 늘리고, 끝 부분 값에 새로 넣는 값으로 Update를 하면 됩니다.따라서, 시간효율성은 O(1)인 Constant하게 이루어 질 수 있습니다. 하지만, 2번 경우처럼 Array 중간에 Insert하는 경우 배열 주소값의 연속성을 유지하기 위해서는 새로운 Array를 만들어야 합니다. 이는 heap을 새로 할당받고 Copy하는 과정을 거쳐야합니다.따라서, O(n)의 시간 효율성을 요구받게 됩니다. Read Dynamic-array의 강점이 두드러지는 Action입니다.배열의 연속성을 이용하여 우리가 원하는 Index의 값으로 Random Access할 수 있습니다. 이 때 시간효율성은 O(1)로 Constant하게 접근할 수 있습니다.※많은 언어에서는 “[]” 기호로 접근할 수 있게 Indexing을 구현해놓았습니다. Update Dynamic-array의 강점이 두드러지는 Action입니다.Update은 바로 위에서 언급한 Read의 action 후에 그 값을 수정하는 Action입니다.시간 효율성은 O(1)로 수행할 수 있고, 구현도 Read 부분과 크게 다른 게 없습니다. Delete Dyanamic array에서 delete를 하는 경우는 크게 두 가지로 나눌 수 있습니다.&lt;1&gt; Array의 끝 부분을 Delete하는 경우 &lt;2&gt; Array의 중간 부분을 Delete 하는 경우 1번 경우에는 size를 1만큼 줄이고 마지막을 None 등의 값들로 다시 처리하면 됩니다.따라서, 시간효율성을 O(1)로 구현이 가능합니다. 하지만, 2번처럼 Array의 중간을 Delete하는 경우 배열 주소값의 연속성을 유지하기위해서우리는 새로운 Array를 만들고 heap을 할당받고 copy를 하는 과정을 거쳐야합니다.따라서, O(n)의 시간 효율성을 요구받게 됩니다. Resize Static array가 아닌 Dynamic array만의 특징입니다.사실 내부 구조는 둘 다 같습니다. 다만, 후자는 Resize를 한다가 차이점입니다.이렇게 Resize를 하는 경우는 아래와 같은 두 가지 경우 입니다. 1. Insert로 인해, 현재의 Capacity보다 Array의 size가 커지려고 할 때기존의 Capacity보다 size가 커지면, 더 이상 input을 넣을 공간이 부족하게 됩니다.이 때, 내부적으로 통상적으로 Capacity의 두 배정도의 새로운 Heap 공간을 요구합니다.그런 다음, 새롭게 할당받은 heap 공간에 현재의 값들을 모두 Copy합니다.기존에 있던 heap을 해제, 반환을 합니다. 2. Delete로 인해, 현재의 Capcity보다 Array이 현재 Size가 턱없이 작을 때현재 쓰고 있는 10밖에 안되는데, 전체 메모리는 100을 할당받고 있으면 비효울적입니다.따라서, Delete로 인해 size가 많이 작아지면 통상적으로 반을 다시 반환을 해야 합니다. 두 가지 모두 O(n)의 시간이 걸리지만, 실제로 Resize는 매번 요구받지는 않습니다.따라서 전체 시간효율성에는 큰 변화가 없습니다. 실제 언어와 구현된 Library ※ Dynamic Array를 구현한 라이브러리 입니다. Python: 기본 구조형 List[]가 내부적으로 Dynamic Array로 되어 있습니다.C++: STL의 Vector가 내부적으로 Dynamic Array로 되어 있습니다.Java: java.util.ArrayList가 내부적으로 Dynamic Array로 되어 있습니다. 직접 구현 코드 Python: Github 코드 보러가기 ","categories": ["linear-ds"],
        "tags": [],
        "url": "http://localhost:4000/linear-ds/2020/04/24/Dynamic-array.html"
      },{
        "title": "Linked List: Nodes 구조의 기본",
        "excerpt":"Linked-list의 기능 실제 언어와 구현된 Library ※ Linked List를 구현한 라이브러리입니다. Python: 표준 라이브러리 Collections의 deque가 Double-Linked-list로 되어있습니다.C++: STL의 list와 front-list가 내부적으로 Linked-list로 되어있습니다.Java: java.util.LinkedList가 내부적으로 Linked-list로 되어있습니다. 직접 구현 코드 Python: Github 코드 보러가기 ","categories": ["linear-ds"],
        "tags": [],
        "url": "http://localhost:4000/linear-ds/2020/04/25/linked-list.html"
      },{
        "title": "Array structure: RAM과 연속성의 마법!",
        "excerpt":"’ 제목 그대로’ RAM의 마법이자, 많은 자료 구조들의 어머니인 Array 구조 입니다.이 글에서는 RAM과 Array 그리고 Dynamic-array에 대해서 설명 하겠습니다. RAM이란?  여기서 계속 말하는 RAM은 우리가 평소에 말하는 하드웨어 “RAM” 그거 맞습니다.이 RAM에 대해서 알아야, Array의 가치를 제대로 이해 할 수 있습니다.  ※CacheMemory(SRAM), MainMemory(DRAM) 등 더 깊은 것은 여기서 다루지 않겠습니다. RAM은 위 그림 처럼 CPU 옆에 붙어서 우리의 명령코드를 수행합니다.CPU가 일련의 명령들을 수행하는 동안 값과 자료들을 읽고 기억하는 공간입니다.ROM과는 다르게, 전원이 꺼지거나 하면 값이 사라지는 volatile 메모리입니다.이까지의 내용은 많은 분들이 이미 아시는 내용 일 것이라고 생각합니다. 하지만 우리가 이 글에서 주목 해야할 것은 바로 아래의 내용입니다. RAM은 Random Access 방식으로 데이터를 읽거나 기억하는 메모리입니다.그럼 Random Access 방식은 멀까요?결론부터 이야기하면, 램에 저장된 어느 데이터든 접근 시간이 거의 동일하다.더 이야기하자면, 데이터의 주소만 알면 RAM은 그 주소로 순간 이동 할 수 있다. 입니다. 랩 안에는 공간이 허용하는 한 집을 짓고, 집을 지을 때마다 주소 값이 생깁니다.우리가 어떤 주소를 알고 그것을 RAM에게 준다면 그 주소로 순간 이동을 합니다.그림으로 표현하면 램(RAM)은 아래와 같다고 생각하면 됩니다.  이 Array는 배열의 연속성을 통해 RAM을 이용한 기본 자료 구조입니다.   다른 방법으로는 Pointer를 통해 RAM을 이용한 Nodes 구조가 있습니다. Array와 연속성: Array란 데이터가 연속되어 저장된 배열입니다.메모리 기준에서 말하면, Array란 데이터들이 연속되는 메모리 주소를 가지는 배열입니다. 여기서 계속 강조되는 것은 배열의 연속성이라는 것입니다.이것이 왜 중요한지는 아파트의 그림과 예를 들어 설명을 드리겠습니다.  일단 Array란 눕힌 아파트와 같다고 생각할 수 있습니다.Array 안에는 아파트의 호실처럼 공간들이 순차적으로 줄지어 있습니다. 각 호실은 사실 제각각 고유의 주소(address)를 가지고 있습니다.각 호실은 연속되어 있기에 주소도 서로 연속되는 값을 가지게 됩니다.아파트이기 때문에 아파트의 주소도 있고 주소는 맨 앞의 호실의 주소와 같습니다.  자, 여기서 우리는 RAM을 광속의 쿠팡맨이다라고 상상해 보겠습니다.쿠팡맨은 마을아파트가 굉장히 많기 때문에 방 하나 하나 주소를 다 기억하지는 못합니다.대신 마을에 있는 아파트의 주소는 본사에 전화를 하게 되면 다 알 수가 있죠.  여기서 우리 쿠팡맨은 FF101아파트의 4호실로 가라!라는 미션을 받게됩니다.쿠팡맨은 광속이기 때문에 방의 주소만 안다면 순식간에 갈 수 있습니다.하지만 안타깝게도 쿠팡맨은 방 하나 하나의 고유의 주소는 모른다는 것이죠.쿠팡맨은 과연 어떻게 방 고유의 주소를 얻을 수 있을까요?  해결 방법은 바로 본사에 전화해서 아파트의 주소를 알아내고아파트의 호실은 연속적이다 라는 것을 이용하여 주소 값을 얻는 것입니다.위 문제의 경우에는 4호실은 0 호실에서 4만큼 떨어져 있으니, 아파트 주소 + 4 = 4호 주소라는 사실을 알 수 있고, 쿠팡맨은 성공적으로 4호실의 주소로 순간이동 할 수 있습니다. 위 이야기가 배열의 연속성을 통해 RAM을 이용하는 Array의 핵심입니다. Array와 관련된 자료구조들 Array와 관련된 자료구조들은 사실 너무도 많습니다.사실 모든 구조가 계속 내려가면 Nodes 또는 Array로 되어 있기 떄문입니다.그 중에서 대표적인 것을 뽑자면 Unordered Map, binaryHeap정도가 있습니다. 중요한 것은 위 자료구조들은 연속성을 이용한 Index 접근이 필요한 구조들이라는 것입니다.즉, Array 약점인 비효율적인 Insert, delete 등 보다 Index 접근이 중요한 구조들입니다. 위를 이해하면 어떤 구조를 구현 할 때 Linked list로 구현해야 하나? Array로 구현해야 하나?고민들은 이전에 구현했던 기억으로 구현하는 것이 아니라 자연스럽게 구현할 수 있게 됩니다. 가령 Map은 Hashing을 통해 얻은 Index를 사용해 빠르게 data에 접근해야 한다라는특성 때문에 “slots을 DynamicArray로 구현하는 것이 좋다”. 라는 통찰을 얻을 수 있습니다. ","categories": ["basic-ds"],
        "tags": [],
        "url": "http://localhost:4000/basic-ds/2020/06/03/array-structure.html"
      },{
        "title": "Nodes structure: RAM과 포인터의 마법!",
        "excerpt":"’ 제목 그대로’ RAM의 마법이자, 자료 구조들의 아버지인 Nodes 구조 입니다.이 글에서는 RAM과 Node structure 그리고 Linked-list에 대해서 설명 하겠습니다. RAM이란?  여기서 계속 말하는 RAM은 우리가 평소에 말하는 하드웨어 “RAM” 그거 맞습니다.이 RAM에 대해서 알아야, Nodes structure의 가치를 제대로 이해 할 수 있습니다.  RAM은 위 그림 처럼 CPU 옆에 붙어서 우리의 명령코드를 수행합니다.CPU가 일련의 명령들을 수행하는 동안 값과 자료들을 읽고 기억하는 공간입니다.ROM과는 다르게, 전원이 꺼지거나 하면 값이 사라지는 volatile 메모리입니다.이 까지의 내용은 많은 분들이 이미 아시는 내용일 거 라고 생각합니다. 하지만 우리가 이 글에서 주목 해야할 것은 바로 아래의 내용입니다. RAM은 Random Access 방식으로 데이터를 읽거나 기억하는 메모리입니다.그럼 Random Access 방식은 멀까요?결론부터 이야기하면, 램에 저장된 어느 데이터든 접근 시간이 거의 동일하다.비유을 들자면, 주소만 알면 그 주소로 순간 이동 할 수 있다. 입니다. 랩 안에는 공간이 허용하는 한 집을 짓고, 집을 지을 때마다 주소 값이 생깁니다.우리가 어떤 주소를 알고 그것을 RAM에게 준다면 그 주소로 순간이동 하는 거죠.그림으로 표현하면 램(RAM)은 아래와 같다고 생각하면 됩니다.  이 Nodes 구조는 Pointer 라는 것을 통해 RAM의 특징을 구현한 자료구조입니다.   다른 방법으로는 연속성을 통해 RAM의 특징을 구현한 Array 구조가 있습니다. Node 구조와 Pointer(포인터)란? Node란 어떤 주소의 포인터와 고유의 값을 Attribute로 가진 객체입니다.메모리 기준에선, 다른 메모리 주소를 알고 있는 하나의 객체입니다. 잠깐, 포인터에 대한 설명을 쉽게 해보겠습니다. 컴퓨터상의 모든 값은 메모리의 주소를 가집니다. Nodes와 관련된 구조들 Nodes와 관련된 자료구조들은 사실 너무도 많습니다.사실 모든 구조가 계속 내려가면 Nodes 또는 Array로 되어 있기 떄문입니다.그 중에서 대표적인 것을 뽑자면 Binary search tree, Trie정도가 있습니다. 중요한 건 Nodes 구조들은 포인터를 이용한 접근과 자료구조 변형이 잦은 구조들이라는 것입니다.즉, 연속적인 주소 접근은 보다는 비규칙적인 주소 접근과 잦은 Insert, Delete가 이루어 지는 구조들입니다. 이를 이해하면, 왜 많은 비선형 구조들(예: Tree, Trie)들이 Node로 이루어 질 수 밖에 없는지그냥 배웠기에 받아들이는 것이 아니라 자연스럽게 이해하실 수 있고 구현도 쉽게 할 수 있습니다. ","categories": ["basic-ds"],
        "tags": [],
        "url": "http://localhost:4000/basic-ds/2020/06/03/nodes-structure.html"
      },{
        "title": "카카오 페스티벌: 보행자 천국",
        "excerpt":"핵심개념 1.기본적인 modular arithmetic2.DP(dynamic programming) 팁 먼저, 답의 정확성에서 문제가 발생하시면 Modular arithmetic에서 실수가 없었는지 체크바랍니다.여기서 필요한 Modular arithmetic은 A%m = (B%m + C%m)%m 단, m = 20170805 입니다. 두 번째로, DP의 아이디어가 중요합니다.이 문제는 2 * (m+1) * (n+1) 크기의 DP가 문제 풀기에 용이합니다.각각 +1을 하는 이유는 i == m-1 이나 j == n-1의 경우를 계산할 때 편하게 하기 위함입니다. DP에는 (a, b)의 형태로 a: 이전에서 가로 방향으로 온 경우 b: 이전에서 세로 방향으로 온 경우로 나누시고 CityMap을 값을 체크하시면서 DP 값들을 처리하시면 됩니다. 그림 설명 각 DP의 값에는 이전에서 가로방향으로 들어온 경우와 세로 방향 들어온 경우로 나눕니다. CityMap이 0인 경우    어떤 방향이든 상관없이 dp[1][i][j+1]으로 저장  어떤 방향이든 상관없이 dp[0][i+1][j]로 저장CityMap이 2인 경우 ※그림에 DP값을 1로 잘못 적었습니다. 1-&gt;2로 생각하시고 봐주세요.   Vertical하게 들어온 값은 오른쪽으로 dp[1][i][j+1]으로 저장  Horizontal하게 들어온 값은 밑으로 dp[0][i+1][j]으로 저장CityMap이 1인 경우 그냥 CONTINUE 시간 효율성 O(m * n * 2) Code: import java.util.*;class Solution {  static final int MOD = 20170805;  public static int solution(int m, int n, int[][] cityMap) {    int[][][] dp = new int[2][m + 1][n + 1];    dp[0][0][0] = 1;    for (int i = 0; i &lt; m; i++) {      for (int j = 0; j &lt; n; j++) {        if (cityMap[i][j] == 0) {          dp[0][i + 1][j] = (dp[0][i + 1][j] + dp[0][i][j] + dp[1][i][j]) % MOD;          dp[1][i][j + 1] = (dp[1][i][j + 1] + dp[0][i][j] + dp[1][i][j]) % MOD;        } else if (cityMap[i][j] == 2) {          dp[0][i + 1][j] = (dp[0][i + 1][j] + dp[0][i][j]) % MOD;          dp[1][i][j + 1] = (dp[1][i][j + 1] + dp[1][i][j]) % MOD;        } else {          ;        }      }    }    return (dp[0][m - 1][n - 1] + dp[1][m - 1][n - 1]) % MOD;  }  public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    int m = Integer.parseInt(sc.nextLine());    int n = Integer.parseInt(sc.nextLine());    int[][] cityMap = new int[m][n];    String line = sc.nextLine();    String[] lines = line.substring(1, line.length() - 1).split(\"\\\\],\\\\[\");    for (int i = 0; i &lt; m; i++) {      String[] newLine = lines[i].split(\", \");      for (int j = 0; j &lt; n; j++) {        cityMap[i][j] = Integer.parseInt(newLine[j]);      }    }    System.out.println(solution(m, n, cityMap));  }}","categories": ["coding test","kakao 2017"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202017/2020/06/03/heavenOfpedestrian.html"
      },{
        "title": "카카오 페스티벌: 사천성",
        "excerpt":"핵심개념 팁 그림 설명 시간효율성 Code: import java.util.*;public class Main {  public static void main(String[] args) {    Scanner sc = new Scanner(System.in);    int m = Integer.parseInt(sc.nextLine());    int n = Integer.parseInt(sc.nextLine());    String[] board = new String[m];    String[] lines = sc.nextLine().split(\", \");    for (int i = 0; i &lt; m; i++) {      String input = lines[i].substring(1, n + 1);      board[i] = input;    }    String result = new Solution().solution(m, n, board);    System.out.println(result);  }}class Solution {  public int checkRemovability(int m, int n, char[][] charBoard) {    char finalRemover = 'a';    for (int i = 0; i &lt; m; i++) {      for (int j = 0; j &lt; n; j++) {        // &lt;First&gt; I'm a wall, Skip myself!        if (charBoard[i][j] == '*')          continue;        // &lt;Second&gt; I'm a point which help some tile to find his partener!        else if (charBoard[i][j] == '.') {          // there are four cases:          char upperCh = userFind.findUpper(m, n, i - 1, j, charBoard);          char lowerCh = userFind.findLower(m, n, i + 1, j, charBoard);          char leftCh = userFind.findLeft(m, n, i, j - 1, charBoard);          char rightCh = userFind.findRight(m, n, i, j + 1, charBoard);          // 1: upper meet left          if (upperCh != '*' &amp;&amp; upperCh != '.' &amp;&amp; upperCh == leftCh)            finalRemover = userFind.findMin(finalRemover, upperCh);          // 2: upper meet right          if (upperCh != '*' &amp;&amp; upperCh != '.' &amp;&amp; upperCh == rightCh)            finalRemover = userFind.findMin(finalRemover, upperCh);          // 3: lower meet left          if (lowerCh != '*' &amp;&amp; lowerCh != '.' &amp;&amp; lowerCh == leftCh)            finalRemover = userFind.findMin(finalRemover, lowerCh);          // 4: lower meet right          if (lowerCh != '*' &amp;&amp; lowerCh != '.' &amp;&amp; lowerCh == rightCh)            finalRemover = userFind.findMin(finalRemover, lowerCh);        }        // &lt;Third&gt; I'm a tile and find my partener!        else {          char curCh = charBoard[i][j];          if (curCh == userFind.findRight(m, n, i, j + 1, charBoard))            finalRemover = userFind.findMin(finalRemover, curCh);          if (curCh == userFind.findLower(m, n, i + 1, j, charBoard))            finalRemover = userFind.findMin(finalRemover, curCh);        }      }    }    return ((finalRemover == 'a') ? -1 : (int)finalRemover);  }  public void Remove(int m, int n, char[][] charBoard, char ch) {    for (int i = 0; i &lt; m; i++) {      for (int j = 0; j &lt; n; j++) {        if (charBoard[i][j] == ch)          charBoard[i][j] = '.';      }    }  }  public void backTracking(int leftTiles, int m, int n, char[][] charBoard,                           ArrayList&lt;Character&gt; answerList) {    if (leftTiles &lt;= 0)      return;    int toBeRemovedTile = checkRemovability(m, n, charBoard);    if (toBeRemovedTile &gt; 0) {      Remove(m, n, charBoard, (char)toBeRemovedTile);      answerList.add((char)toBeRemovedTile);      backTracking(leftTiles - 1, m, n, charBoard, answerList);    } else      return;  }  public String solution(int m, int n, String[] board) {    char[][] charBoard = new char[m][n];    ArrayList&lt;Character&gt; answerList = new ArrayList&lt;Character&gt;();    userUtil.initializeCharBoard(m, n, charBoard, board);    int tilesNumber = userUtil.checkTiles(m, n, charBoard);    backTracking(tilesNumber, m, n, charBoard, answerList);    return ((answerList.size() == tilesNumber) ? userUtil.getString(answerList)                                               : \"IMPOSSIBLE\");  }}class userFind {  public static char findRight(int m, int n, int x, int y, char[][] charBoard) {    while (y &lt; n &amp;&amp; charBoard[x][y] == '.') {      y++;    }    return ((y &gt;= n) ? '*' : charBoard[x][y]);  }  public static char findLeft(int m, int n, int x, int y, char[][] charBoard) {    while (y &gt; 0 &amp;&amp; charBoard[x][y] == '.') {      y--;    }    return ((y &lt; 0) ? '*' : charBoard[x][y]);  }  public static char findUpper(int m, int n, int x, int y, char[][] charBoard) {    while (x &gt; 0 &amp;&amp; charBoard[x][y] == '.') {      x--;    }    return ((x &lt; 0) ? '*' : charBoard[x][y]);  }  public static char findLower(int m, int n, int x, int y, char[][] charBoard) {    while (x &lt; m &amp;&amp; charBoard[x][y] == '.') {      x++;    }    return ((x &gt;= m) ? '*' : charBoard[x][y]);  }  public static char findMin(char a, char b) {    if (a &lt;= b)      return a;    else      return b;  }}class userUtil {  public static String getString(ArrayList&lt;Character&gt; list) {    StringBuilder builder = new StringBuilder(list.size());    for (char ch : list) {      builder.append(ch);    }    return builder.toString();  }  public static void initializeCharBoard(int m, int n, char[][] charBoard,                                         String[] board) {    for (int i = 0; i &lt; m; i++) {      for (int j = 0; j &lt; n; j++) {        charBoard[i][j] = board[i].charAt(j);      }    }  }  public static int checkTiles(int m, int n, char[][] charBoard) {    HashSet&lt;Character&gt; tempSet = new HashSet&lt;Character&gt;();    for (int i = 0; i &lt; m; i++) {      for (int j = 0; j &lt; n; j++) {        if (charBoard[i][j] != '.' &amp;&amp; charBoard[i][j] != '*')          tempSet.add(charBoard[i][j]);      }    }    return tempSet.size();  }}","categories": ["coding test","kakao 2017"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202017/2020/06/04/%EC%82%AC%EC%B2%9C%EC%84%B1.html"
      }]
