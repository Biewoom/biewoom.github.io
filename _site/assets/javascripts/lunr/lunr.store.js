var store = [{
        "title": "카카오 테스트: 자물쇠와 열쇠",
        "excerpt":"핵심개념   Matrix rotation팁 첫 번쨰: 효율적인 Time-complexity를 크게 고민하시지는 않아도 될 거 같습니다.원체, N과 M의 최대 범위값이 크지 않아서 여러 번의 Nested-loop하셔도 통과가 가능합니다.저 같은 경우, O( (n+m)2 * (m2 + n2 ) ) 이었는데, 통과가 되었습니다. 두 번째: 회전과 이동의 개념을 정확하게 이해하셔야 합니다.회전들은 서로 배반적으로 작용합니다. i.e 경우의 수에서 말하는 합의 법칙(or)이 성립합니다.저도 수학적인 증명까지는 못했으나, 종이에, 3*3 정도 grid를 그리셔서 회전과 이동을 해보시면 아시게 될겁니다. 세 번째: Virtual Matrix를 이용하라.문제에서 제시한 조건을 충족하면서 Lock과 keys의 값을 효율적으로 비교하기 위해 크기가(n + 2m)(n + 2*m)인 큰 Virtual Matrix를 새로 그려서 값을 비교했습니다.Space complexity가 약간 커지지만, 코드가 이해하기 쉬워집니다. 마지막: XOR을 이용해서 홈과 돌기를 서로 비교하시면 더욱 깔끔한 코드가 될거같습니다. Code: import osimport sysdef Counterclockwise(matrix):    new_matrix = [[0]*len(matrix) for i in range(len(matrix))]    for i in range(len(matrix)):        for j in range(len(matrix)):            new_matrix[len(matrix)- 1 - j][i] = matrix[i][j]    return new_matrixdef solution(keys, locks):    m = len(keys); n = len(locks); lock_x = lock_y = m-1    options = [0, 90, 180, 270]    for op in options:        if op != 0: keys = Counterclockwise(keys)        for i in range(0, m+n):            for j in range(0, m+n):                VirtualMatrix = [[None]*(n+2*m) for i in range((n+2*m))]                key_x = i; key_y = j                for x in range(0, m):                    for y in range(0, m):                        VirtualMatrix[key_x+x][key_y+y] = keys[x][y]                Unlock = True                for z in range(0, n):                    for k in range(0, n):                        if VirtualMatrix[lock_x+z][lock_y+k] is None:                            if locks[z][k] == 0: Unlock = False                            else: continue                        else:                            if VirtualMatrix[lock_x+z][lock_y+k]^locks[z][k] != 1: Unlock = False                            else: continue                if Unlock: return True    return FalseCode-review:   논리구조가 간단명료한가?          VirtualMatrix를 사용하니 논리구조 자체는 논리정연했다.        코드를 Readible 하게 적었는가?          x,y,z,k 등의 변수 이름은 친절하지 않게 적었다.        최적화는 하였는가?          전체적인 Complete-search를 해야해서 좋은 time-complexity라고 할 수는 없다.      논리구조는 명료했지만 space-complexity가 좀 더 비효율적이 되었다.      ","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/13/Lock.html"
      },{
        "title": "카카오 테스트:가사 검색",
        "excerpt":"핵심 개념:   Trie  prefix and suffix  string 길이팁: 1) 문제의 조건을 보시면, query안에,  ‘?’가 있을 수 있는 경우는:  prefix 또는 suffix 또는 ‘?????’ 이렇게 세 가지 경우가 있습니다.  그래서 트리 하나로 해결하시는 것보다, 이 경우들을 다 고려하시면서 한 개이상의 Trie를 만드시는 게 좋습니다. 2) 이 문제에서는 substring을 구하는 문제가 아니고 match하는 string을 구하는 것이기 때문에 아예 처음부터, string의 길이를 이용하시는 것도 좋습니다. 3) 다른 응용으로는, 단순한 Trie가 아니라, Trie 내부에, subtree의 노드 수를 계속 추적할 수 있는 값을 추가하시면 훨씬 효율적입니다. More Tip:문제에서 중복이 있을 수 있다라는 이야기가 나와서 중복을 없애고 시작하면, 좀 더 효율적이지 않나? 라고생각이 들 수도 있습니다. 하지만 사실 이건 크게 의미가 없습니다. 우리는 이전에 같은 string이 있었는지 체크하기 위해 hash function을 적용 하는 과정에서 string 전체를 적어도 한 번을 다 돌아야 합니다.그러므로, O(len(string))으로 Trie에서의 탐색하는 것과 같은 time complexity를 가집니다. Code 풀이는 위의 설명을 참조해서 코드를 직접 보시면서 이해하면 좋겠습니다. import osimport sysfrom collections import defaultdictclass Trie:    def __init__(self):        self.root = {} # chr|visited    def insert(self, s):        cur = self.root        while s:            if s[0] not in cur: cur[s[0]] = [ {} , 0 ]            cur[s[0]][1] += 1            cur = cur[s[0]][0]            s = s[1:]    def find(self, s)-&gt;int:        cur = self.root; pre_v = 0        while s:            if s[0] == '?': return pre_v            else:                if s[0] not in cur: return 0                pre_v = cur[s[0]][1]; cur = cur[s[0]][0]            s = s[1:]        return pre_vdef solution(words, queries):    prefix_dict = defaultdict(Trie)    suffix_dict = defaultdict(Trie)    len_dict = defaultdict(int)    result = []    for word in words:        prefix_dict[len(word)].insert(word)        suffix_dict[len(word)].insert(word[::-1])        len_dict[len(word)] += 1    for q in queries:        if q[0] == '?' and q[-1] == '?':            result.append(len_dict[len(q)])        elif q[-1] == '?': #preffix_query            result.append( prefix_dict[len(q)].find(q))        elif q[0] == '?': #suffix_query            result.append( suffix_dict[len(q)].find(q[::-1]) )        else:            print(\"IMPOSSIBLE\", q)    return result","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/13/search_lyrics.html"
      },{
        "title": "Trie: 자동 완성의 비밀!",
        "excerpt":"혹시 검색어, 채팅 추천이 어떤 원리로 운영되는 지 궁금하신 적 있으신가요?현실적으로는 프론트, 백, 데이터 프로세싱 등의 다방면의 접근이 필요하지만그 중 백에서 사용 되는 모델은 트라이(Trie)를 기반으로 하는 것이 많습니다! 이는 트라이의 기능이 검색어를 효율적으로 찾는 것에 도움이 되기 떄문인데요.우리는 여기서 Basic 한 Trie에 간단히 대해서 알아보겠습니다.   ※ 현재 대부분 기업은 Basic이 아닌 훨씬 최적화, 변형된 트라이를 사용합니다. 트라이는 어떤 기능을 하나요? 트라이는 String-search, Substring-search 등을 수행합니다이 중 String-search 기능을 예로 설명하겠습니다.우리는 검색어 관리팀이고, n개 낱말의 리스트를 가지고 있다고 합시다.가진 리스트는 {‘한국은행’, ‘한국만세’, ‘일본’, ‘국장’, ‘국물’,…, ‘국뽕’} 이 때, 한 유저가 기존의 리스트에 ‘국뽕‘이라는 낱말이 있는 지가 궁금합니다.핵심: 어떻게 하면 리스트에서 이 낱말이 있는 지를 효율적으로 알 수 있을까요??※ 다음으로 넘어가기 전에 혼자 한 번 고민해봅시다! Brute-force 하게 해봅시다.  어렵게 생각하지 말고 리스트 안의 것 모두를 우리의 Query인 ‘국뽕’과 하나씩 비교합시다한국은행과 국뽕을 먼저 비교하고, 다음은 한국만세, 다음은 일본 … 등등 n-1번 까지 있던 모든 글자와는 틀렸다는 것을 확인하고 마지막에서 와서야 겨우‘국뽕’과 비교를 할 수 있게 되고, 우리는 ‘국뽕’이라는 낱말이 있다는 것을 발견합니다. 이를 시간 효율성에 비추어 생각하면 최악의 경우는 O(N*M)입니다.이 때, N = 리스트의 길이, M = 쿼리 낱말의 길이입니다.운좋게, 쿼리가 하나 일 경우에는 이 Brute-force 방법도 참아 줄만 합니다만 만약 궁금한 게 하나의 쿼리가 아니라, [‘국뽕’, ‘일본’, ‘나라’, ..] 처럼 K 개 쿼리의 리스트이면,각각 쿼리도 똑같은 과정을 거치기에 시간효율성은 O(N* M *K)가 될 것입니다.위의 시간 효율성은 굉장히 비효율적이며, 현실에서도 적용하기 어렵습니다.이것을 해결하기 위해서 아래와 같은 트라이(Trie)라는 구조가 고안되었습니다. 트라이의 구조 트라이의 아이디어는  낱말을 하나 하나 글자로 쪼개어 트리로 저장한다입니다.예를 들면 ‘한국은행’ -&gt; [‘한’, ‘국’, ‘은’, 행’], ‘일본’ -&gt; [‘일’, ‘본’]과 같이 모두 쪼갠 후에 아래와 같은 과정을 거쳐 트리 형태로 저장을 합니다. Trie를 만드는 단계:만드는 단계는 아래와 같은 두 가지 경우로 진행됩니다.   낱말을 글자로 쪼갠 후 노드에 공통되는 글자가 있으면 그 글자 노드로 진행  낱말을 글자로 쪼꺤 후 노드에 그 글자가 없다면, 글자에 해당되는 노드를 만들고 진행아래는 Trie를 만드는 과정 중 ‘한국만세’ 라는 낱말을 넣는 차례입니다.  아래는 Trie를 만드는 과정 중 ‘일본’ 이라는 낱말을 넣는 차례입니다.  Trie를 다 만든 단계:위의 과정이 모두 끝나면 아래와 같습니다.  Query를 찾는 단계:우리가 찾고싶은 쿼리는 ‘국뽕’이라고 한다면 먼저 ‘국‘을 가진 노드를 찾고‘국‘에 해당하는 다음 노드로 넘어간다음, ‘뽕‘이라는 노드를 찾으면 됩니다  이번에는 ‘일본’이라는 낱말을 찾는 경우입니다.  이번에는 ‘나라’ 라는 낱말을 찾는 경우인데, 첫 번째 노드부터, ‘나’ 라는 글자가존재하지 않습니다. 따라서 여기엔 ‘나라’ 라는 낱말는 없다 라는 걸 바로 알 수 있습니다  트라이의 장단점 장점:Query를 찾을 때, Brute-force를 이용하는 것보다 좋은 time-complexity를 가집니다.특히, 처리하는 Query의 수가 많아지면 질수록 이 구조은 정말 유용합니다. 구현하는 것도 어렵지 않고 아이디어도 간단해서 여러 응용을 하기 좋습니다.예로: Visted 같은 변수를 추가해서, 갯수를 추적하는 것도 가능합니다. 단점:space-complexity면에서는 기존의 것보다 비효율적입니다.대부분 구현과정에서 Map을 쓰게 되는데, 이 때 space가 꽤 듭니다. 쿼리가 워낙 적으면 오히려 시간이 걸릴 수도 있다.일단 이 구조는 만들 때도 String hash를 하기 때문에 시간이 걸립니다.따라서 쿼리 양은 되게 적고, 저장되어있는 단어는 상대적으로 많을 때오히려 Brute-force한 것보다도 더 안좋은 execution-time을 가질 수도 있습니다. 실제 구현 by Python 구현 아이디어:   linked-list  Dictionary  iteration  TreeCode: class Trie:    def __init__(self):        self.root = {}    def insert(self, s):        cur = self.root        while s:          if s[0] not in cur: cur[s[0]] = {}          cur = cur[s[0]]          s = s[1:]        cur[0] = {}    def find(self, s)-&gt;bool:        cur = self.root;        while s:            if s[0] not in cur: return False            cur = cur[s[0]]            s = s[1:]        if 0 in cur: return True        else: return False","categories": ["non-linear-ds","advanced-ds"],
        "tags": [],
        "url": "http://localhost:4000/non-linear-ds/advanced-ds/2020/04/14/Trie.html"
      },{
        "title": "카카오 테스트:블록 이동",
        "excerpt":"PS에서는 나오기 힘든 코딩을 요구합니다.카카오 Tech 측에서도, ‘상당한 난이도의 코딩을 요구한다.’ 라고 언급할 정도로보통 ProblemSolving 문제 이상의 상당한 구현력을 요구합니다. 핵심 개념:   BFS  HashMap  Memoization - visited풀이법:   최소 시간을 구하기 위해서 BFS을 이용한 Outer-loop에서 최소 시간인 time을 추적합니다. 마지막 칸을 만나게 되면 time을 Return 합니다.  경우의 수 가지치기를 위해, HashMap을 이용한 memoization을 활용해 이미 지났던 경로를 다시 지날 경우는 Queue에서 제외합니다.  이 때, HashMap 안에는 (좌표1, 좌표2) 가 하나의 키의 역할을 하며   - 조건1  rotate할 때, 문제 조건에 따르면, 축 (axis) 대각측 칸이 0임을 계속 추적해야 하는데, 이 점에서 저는 어떤 패턴도 발견하지 못해서 모든 경우에 맞게 하드코딩을 하였습니다.조건1이 필요한 이유:i.e; ((0,0), (0,1)) 와 ((0,1), (0,0)) 같은 건 같은 하나의 key로 취급을 해야하기 때문입니다. HardCoding 참고: style: 가로모양 or 세로모양, axis: 좌표1가 축 or 좌표2가 축, direction: 시계방향 or 반시계 방향 import osimport sysfrom collections import defaultdict# style|axis|direcitonValueArray = [[[None]*2 for i in range(2)] for i in range(2)]CheckArray = [[[None]*2 for i in range(2)] for i in range(2)]def check(coord1, coord2, board):    x1, y1 = coord1; x2, y2 = coord2    if min(x1, y1, x2, y2) &lt; 0: return False    elif max(x1, y1, x2, y2) &gt;= len(board): return False    elif board[x1][y1] == 1 or board[x2][y2] == 1: return False    else: return Truedef goNEWS(coord1, coord2, i):    move = [(-1,0), (0, 1), (0, -1), (1,0)]    new_coord1 = (coord1[0]+move[i][0], coord1[1]+move[i][1]); new_coord2 = (coord2[0]+move[i][0], coord2[1]+move[i][1])    return sorted((new_coord1, new_coord2))def rotate(coord1, coord2, board, axis, direction):    global ValueArray, CheckArray    axis_coord = coord1 if axis == 0 else coord2    style = 0 if coord2[1] &gt; coord1[1] else 1    Check = CheckArray[style][axis][direction]    Value = ValueArray[style][axis][direction]    Check_coord = (axis_coord[0] + Check[0], axis_coord[1]+Check[1])    if 0 &lt;= Check_coord[0] &lt; len(board) and 0 &lt;= Check_coord[1] &lt; len(board) and board[Check_coord[0]][Check_coord[1]] == 0:        return sorted( ( (axis_coord[0]+Value[0], axis_coord[1]+Value[1]), axis_coord) )    else:        return ((-1,-1), (-1,-1))def initialize(ValueArray, CheckArray):    CheckArray[0][0][0] = (-1,1);   ValueArray[0][0][0] = (-1,0)    CheckArray[0][0][1] = (1,1);    ValueArray[0][0][1] = (1,0)    CheckArray[0][1][0] = (-1,-1);  ValueArray[0][1][0] = (-1,0)    CheckArray[0][1][1] = (1,-1);   ValueArray[0][1][1] = (1,0)    CheckArray[1][0][0] = (1,1);    ValueArray[1][0][0] = (0,1)    CheckArray[1][0][1] = (1,-1);   ValueArray[1][0][1] = (0,-1)    CheckArray[1][1][0] = (-1,1);   ValueArray[1][1][0] = (0,1)    CheckArray[1][1][1] = (-1,-1);  ValueArray[1][1][1] = (0,-1)def solution(board):    global ValueArray, CheckArray    initialize(ValueArray, CheckArray)    HashMap = defaultdict(int)    Q = [( (0, 0), (0, 1) )]    time = 0    while True:        next_Q = []        while Q:            coord1, coord2 = Q.pop(0)            if not check(coord1, coord2, board): continue            if (coord1, coord2) in HashMap and HashMap[(coord1, coord2)] &lt;= time: continue            if coord2[0] == len(board)-1 and coord2[1] == len(board)-1: return time            HashMap[(coord1, coord2)] = time            for i in range(4):                next_Q.append(tuple(goNEWS(coord1, coord2, i)))            for axis in range(2):                for direction in range(2):                    next_Q.append(tuple(rotate(coord1, coord2, board, axis, direction)))        time += 1        Q = next_Q","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/15/move-block.html"
      },{
        "title": "BFS:최단 경로의 비밀!",
        "excerpt":"지도 앱을 이용해 최단 경로를 찾거나 주변에 가까운 음식점은 어떤 것이 있는지같은 기능들 한 번씩은 사용해 보셨죠. 어떤 원리가 있는 지 궁금하신 적 있나요?이 안에는 프론트, 백, 데이터프로세싱, GPS등 여러 기술이 복잡하게 있지만그 중 백에서는 BFS을 기반한 알고리즘이 쓰이는 경우가 많습니다.과연 BFS란 머고 어떤 기능으로 위 기능들을 할 수 있는지 알아보겠습니다. BFS는 어떤 기능을 하나요? BFS는 길찾기 또는 주변탐색 같은 노드탐색기능을 수행할 수 있습니다.비슷한 기능을 수행하는 알고리즘으론 DFS(depth first search)가 있습니다. BFS는 Breath-First-search의 약자로 너비-우선-탐색을 의미하는데요.너비를 우선 탐색하기 때문에, 가장 가까운 노드 탐색이나, 주변에 있는 노드를 탐색하는 경우는 DFS보다 좀 더 효율적이라는 장점을 가집니다! 이 중 ‘가장 가까운 노드 탐색’ 기능을 예와 함께 자세히 설명하겠습니다. 철수가 여행 중 배가 고파 짜장면을 먹을려고 하는데, 이 동네에는 3개의 중국집이 있습니다.철수는 너무 배가 고파서 현재 위치에서 가장 가까운 중국집에 가서 짜장면을 먹으려고 합니다.  위는 동네의 지도이고 철수는 어떻게 하면 효율적으로 가장 가까운 중국집을 찾을까요?※ 다음으로 넘어가기 전에 혼자 한 번 고민해봅시다! brute-force하게 해봅시다. 일단 철수 위치에서 갈 수 있는 모든 노드를 조사하고 그 노드가 중국집이라면그 거리 기록하고, 기록한 거리를 모두 비교해서 가까운 중국집을 알아내는 방법입니다.  위처럼 구하면, 이 동네에서 현 위치에서 가장 가까운 중국집은 황룡반점이다.라는 것을 알 수 있고, 철수는 현 위치에서 1M 떨어진 청룡반점으로 갈 것 입니다. 하지만 이는 모든 노드와 길을 가봐야지 최단 거리를 알 수 있다는 것이죠.만약 동네가 커질수록, 즉 Nodes와 edges가 많아질수록 굉장히 비효율적이 됩니다.이 때 time-complexity를 구해보면, O(N+M) 입니다.(이 떄, N = nodes의 수, M = Edges의 수 = 길의 수) 이 비효율성을 해결하기 위해서 BFS라는 알고리즘을 고안하게 되었습니다. BFS: BFS를 이용한 풀이법은 거리를 기준으로 Greedy하게 문제를 접근해서 푸는 것입니다.풀어 말하면, 가까운 거리의 노드부터 차례 차례 구하다 보면 가장 먼저 만난 노드가 정답이다.라는 아이디어인데, 먼저, 거리를 기준으로 노드를 구한다는 것을 설명하겠습니다. 거리를 기준으로 노드를 구하다는 것은 그림으로 표현하면 아래와 같습니다. 1번 경우: 먼저 거리가 1m인 Node들을 구하는 경우입니다.  2번 경우: 거리가 2m인 Node 들을 구하는 경우입니다.  3번 경우: 거리가 3m인 Node들을 구하는 경우입니다.  우리는 위의 BFS과정에서 약간의 직관을 사용하면 문제를 쉽게 풀 수 있습니다.바로 첫 번쨰의 경우만 진행하고 두 번쨰, 세 번째 경우는 생략한다.라는 것입니다.첫 번째 경우에서 중국집을 만나면, 그 중국집이 바로 가장 가까운 중국집입니다.이유는 다음 경우에서의 중국집들은 이 중국집보다 멀리 있을 수 밖에 없기 때문입니다. BFS의 장단점: 장점:위처럼 최단거리 노드를 탐색하는 경우에는 정말 특화되어있습니다.Time-complexity는 지도의 구성(Topology)에 따라 다르지만 기존의 O(N+M) 보다는훨씬 좋은 Time-complexity를 보유할 수 있습니다. 알고리즘이 간단하고 딴 곳에 쓰기도 좋아서 다른 알고리즘에도 자주 쓰이기 좋습니다.대표적으로 다익스트라 알고리즘, Kruaskal 알고리즘에서 BFS를 이용합니다. 단점:경우에 따라 BFS를 썻을 때 논리 구조가 복잡해지고 구현하기 쉽지 않을 수 있습니다.이는 BFS가 각 Node별로 Parallize하게 진행되기 때문입니다.※ Parallel programming을 할 수 있기 때문에, 장점으로 될 수 있겠네요 실제 구현 by Python import osimport sysfrom collections import defaultdictdef BFS(nodes, edges):  #make edges list  adj_list = defaultdict(list)  for edge in edges:    node1, node2 = edge    adj_list[node1].append(node2)    adj_list[node2].append(node1)  #bfs  Q = []; Q.append('철수 위치')  visited = set()  while Q:    cur_node = Q.pop(0)    if cur_node in visited: continue    visited.add(cur_node)    if cur_node[-2:] == '반점': return cur_node # 중국집    for next_node in adj_list[cur_node]: Q.append(next_node)","categories": ["graph-theory","basic-algo"],
        "tags": [],
        "url": "http://localhost:4000/graph-theory/basic-algo/2020/04/16/bfs.html"
      },{
        "title": "Matrix-roatation:그림 90도 회전의 비밀!",
        "excerpt":"PPT를 만들거나 포토샵을 수정할 때, 그림을 시계방향 또는 반시계방향으로90도, 180도, 270도 회전을 하신 적이 있으신가요?  우리는 마우스를 이용해 돌리지만,컴퓨터 안에서는 어떤 일이 벌어지고 있을까요?답부터 말하자면, 컴퓨터는 Matrix-rotation을 이용해 그림을 90도 회전합니다.이 Matrix-rotation에 대해서 간단히 알아보도록 하겠습니다.   참조- 여기서는 Inplace가 아닌 Extra memory를 쓴 matrix-rotation에 대한 설명입니다. 그림파일은 무엇인가? 주제에 들어가기 앞서서, 그림파일 이란 무엇인지 아셔야합니다. 정말 간단하게 컴퓨터는 그림파일을 어떻게 인식하고 있는지 설명하겠습니다.  정말 간단하게 설명하면, 위 그림처럼 각 그림은 작은 Pixel들로 이루어져 있고각 Pixel들은 숫자의 행렬(Maxtrix) 형태로 구성되어 있습니다!이 말은 결국 모든 그림은 큰 숫자의 행렬(Matrix)모양으로 존재하고 있다는 것입니다. 그럼, 그림을 회전 시킨다는 건?  결국 그림을 회전시킨다는 것은 다시 그림을 만드는 데그 그림은 본래 그림의 행렬 원소를 적당한 패턴으로 재배열하여 만든 행렬입니다. 시계방향으로 90도로 회전  위와 같이 시계방향일 때, 행렬도 똑같이 90도를 회전시킨다고 상상하고 돌리면행렬로 생각했을 때는 행렬의 좌표는 아래와 같은 패턴을 따른다는 것을 알 수 있습니다.  패턴에 따르면, 행렬 좌표로 생각했을 때 새로운 행렬의 x좌표 = 기존의 y좌표이고새로운 행렬의 y좌표 = 행렬의 크기 - 기존의 x좌표 - 1 입니다. 구현 by Python def Clockwise(matrix):    new_matrix = [[0]*len(matrix) for i in range(len(matrix))]    for i in range(len(matrix)):        for j in range(len(matrix)):            new_matrix[j][len(matrix) - i - 1] = matrix[i][j]    return new_matrix반시계방향으로 90도로 회전  위와 같이 반시계방향일 때, 행렬도 똑같이 90도를 회전시킨다고 상상하고 돌리면행렬로 생각했을 때는 행렬의 좌표는 아래와 같은 패턴을 따른다는 것을 알 수 있습니다.  패턴에 따르면, 새로운 행렬의 x좌표 = 행렬의 크기 - 기존의 y좌표 - 1 이고새로운 행렬의 y좌표 = 기존의 x좌표 입니다. 구현 by Python def Counterclockwise(matrix):    new_matrix = [[0]*len(matrix) for i in range(len(matrix))]    for i in range(len(matrix)):        for j in range(len(matrix)):            new_matrix[len(matrix)- 1 - j][i] = matrix[i][j]    return new_matrix  돌리고자 하는 각도가 180, 270일 떄는?이미 아시겠지만, 위의 과정들을 연속해서 하면 됩니다. ","categories": ["misc","basic-algo"],
        "tags": [],
        "url": "http://localhost:4000/misc/basic-algo/2020/04/17/matrix-rotation.html"
      },{
        "title": "HashTable: 전화번호 찾기의 비밀!",
        "excerpt":"휴대폰에서 전화번호 검색을 위해 상대방의 이름을 쳐서 검색한 적이 있으신가요?이 때, 내부에는 효율적인 검색을 위해 HashTable 를 이용하여 전화번호를 찾습니다.이 글에선 과연 HashTable는 무엇인지, 어떤 원리가 숨어있는 지를 알아보겠습니다.   참조: HashTable은 기본적인 DS로 다른 알고리즘이나 DS에 정말 많이 쓰입니다. HashTable은 어떤 기능을 하나요? 어떤 값을 빠른 시간에 Search하거나 값을 Update를 할 수 있는 자료 구조입니다.자세히 이야기하면, 키(key)를 통해 얻고자 하는 값에 접근 하는 자료구조입니다. 여러 기능 중 HashTable의 Search의 효율을 예와 함께 설명을 드리겠습니다. 문제 제시: 한 시골 학교에 6명의 학생이 있는 반과 그 반의 선생님이 있습니다.어제 수학 시험을 쳤고 선생님은 각 학생의 수학 점수 기록을 가지고 있습니다.이 중 ‘재석’이라는 학생이 자신의 수학점수가 궁금해서 선생님을 찾아 왔습니다.  위는 수학점수 기록이고, 선생님은 어떻게 효율적으로 ‘재석’의 수학 점수를 알 수 있을까요?※스스로 한 번 방법을 생각해봅시다! Brute-force하게 해봅시다. 단순하게 위에서부터 학생의 이름을 한 명씩 비교해서 찾을 수 있습니다.그 과정은 아래와 같습니다.  우리가 찾고 싶은 건 ‘재석’ 학생이지만 데이터의 첫 번째 칸은 ‘동훈’ 학생입니다.따라서 다음으로 넘어갑니다.  위의 경우에도 ‘재석’ 학생의 데이터가 아닙니다.이처럼 이름이 찾는 이름이 아닐 경우에는 계속 다음 데이터로 넘어갑니다.  마지막에 비로소 재석의 이름에 해당하는 데이터를 찾았습니다. 하지만 위 방법으로 진행했을 경우, 최악의 경우 처음부터 모든 데이터를 검사해야 합니다.심지어 왼쪽처럼 이름을 비교하는 상황에도 시간 cost가 발생합니다. 찾는 과정은 Time-complexity를 보았을 때, 최악의 경우는 O(N*M)입니다.(이 때 N = 학생 수, M = 학생 이름의 길이) 더 나아가, ‘재석’ 뿐 아니라 다른 학생들도 수학 점수가 궁금해서 찾아오면 어떡할까요?매 학생이 물을 때마다, 모든 데이터를 체크해야 하고, 이건 굉장히 비효율적입니다.만약 K명의 학생이 물어본다고 가정하면 시간 소모는 O(N*M *K)가 됩니다.따라서 물어보는 학생이 많으면 많을 수록 소모되는 시간은 기하급수적으로 커집니다.이 비효율성을 줄이고자, 다음과 같은 HashTable이라는 자료구조가 고안되었습니다. HashTable: 이 문제를 해결하는 아이디어는 Hashing와 Dynamic-array의 마법을 이용하는 것입니다.사실, 이 두 가지의 비밀 뒤에는 수학, 통계, LUT 등 여러가지 고려할 것이 많습니다.하지만, 이 글에서는 HashTable의 전체적인 구조에 관해서만 간단히 알아보겠습니다.    -참조 Dynamic-array의 마법을 알고 싶으면 Dynamic-array-참조 Hashing의 마법을 알고 싶으면 Hashing 전체적인 구조:※ 쉬운 이해를 위해, 몇 개의 전제 조건을 설정하겠습니다.   10개 slots의 slots-list로 시작  사용자 임의의 한글-LUT(lookupTable)  사용자 임의의 String-Hash 함수  Birthday-Paradox는 신경 쓰지 않음  잘못된 Hashing 함수로 인한 Duplicate-key는 신경 쓰지 않음초기의 HashTable: 위는 아직 아무런 Key와 데이터가 없는 초기의 HashTable을 만든 모습입니다.HashTable은 Keys - Hash - slots의 구조로 이루어져 있다고 생각하면 됩니다.slots은 초기 사이즈가 10인 Dynamic-array로 되어있습니다.Hashing 함수는 다음과 같은 두 단계로 이루어져있습니다.   String의 각 글자의 값을 합칩니다.  합친 값을 slots의 갯수로 %(Modulo)를 합니다.Key를 받으면, Hashing이 Key를 Slots의 알맞은 index의 값으로 바꾸어 줍니다.오른쪽은 임의의 한글-LUT로 Hashing의 값을 구할 때 도와줍니다. HashTable 데이터를 넣는 과정: 아래는 ‘동훈’의 데이터를 넣는 과정입니다.  데이터를 넣는 과정은 크게 5단계로 이루어 집니다.   ‘동훈’ 학생의 이름이 Key로 들어갑니다.  ‘동훈’ 각각 ‘동’, ‘훈’에 해당하는 Decimal 값을 LUT에서 찾습니다.  찾은 Decimal값을 Hash-function에서 두 가지 단계로 처리합니다.  나온 값 3에 해당하는 slots의 Index 를 찾습니다.  해당하는 index의 slot에 ‘동훈’의 점수인 15를 넣습니다.아래는 ‘명수’의 데이터를 넣는 과정입니다.  HashTable에 데이터를 다 넣은 상태: 아래는 모든 학생의 데이터를 다 넣고 난 후 HashTable의 모습입니다.  HashTable 데이터를 찾는 과정: 아래는 ‘재석’ 학생의 데이터를 찾는 과정입니다.  데이터를 찾는 과정은 데이터를 넣을 때의 과정과 비슷합니다.   Hash-func을 통해서 ‘재석’의 Index 값인 4를 찾는다.  slots에서 index가 4인 데이터에 접근한다.  index가 4인 slot에 저장된 데이터인 ‘100’을 return 한다.아래는 Keys에 없는 ‘홍철’ 학생의 데이터를 찾는 과정입니다.  만약 기존의 키에 없었던 ‘홍철’이라는 학생 데이터를 찾으려고 하면위처럼 Hash-func에 의해 index가 1인 slots에 접근하게됩니다.하지만, index가 1인 slot에는 데이터가 없고 따라서 Null을 Return 합니다.   실제론, Birthday-paradox 같은 문제로 Collision이란 것이 생깁니다.이를 해결하기 위한 전략으로는 Open-address나 channing 등 몇 가지가 있습니다.더 자세히 알아보기 HashTable의 평가: 일단 data를 Insert할 떄는 brute-force 방법보다 더 걸릴 수 밖에 없습니다.각 데이터는 Hash-func을 거쳐 저장되기 때문에 그 만큼 더 걸리는 것이죠. Big-O notation으로 따지면, O(N*M)의 시간이 걸립니다.(이 때, N = 넣고자 하는 학생 수, M = 각 학생의 이름 길이)넣을 때의 시점에선 이전 방법보다 효율성이 좋다고는 하기 어려울 거 같습니다. 하지만, 물어보는 학생의 경우, 즉 쿼리를 처리할 때는 이전보다 훨씬 좋습니다.이전에는 매번 가지고 있던 모든 데이터를 체크해야 했지만 이번에는 그렇지 않습니다.각 학생은 자신의 이름을 Hash-func에만 넣기만 하면 바로 Index를 얻을 수 있습니다.이 때 얻은 Index의 slot은 Dynamic-array의 마법으로 바로 접근할 수 있습니다. Big-O notation으로 보면, O(K*M)의 시간이 걸립니다.(이 때, K = Query의 수, M = 각 Query 학생의 이름 길이)이 시간이 걸리는 이유는 각 Query들은 Hash-func 과정을 해야하기 때문에 어쩔 수 없이Hash-func에 걸리는 시간인 O(M)을 소모할 수 밖에 없습니다. 하지만 Search하는 시간은O(1)으로 Linear하게 바로 원하는 값에 접근할 수 있습니다.따라서, 이전보다 훨씬 좋은 Query 처리 속도를 가진다고 할 수 있습니다. HashTable과 관련된 용어: 구현 언어에 따라 또는 구현 방법에 따라 또는 잠깐 언급한 Collision 전략에 따라관련 용어들은 조금씩 다릅니다. 자주 쓰이는 것들로 HashMap, Map, Dictionary가 있습니다.하지만 핵심은 Key-Value로 pair이 된 Collection이라는 것에서 같습니다. 참고로, Python에서는 Dictionary, Set이 대표적인 HashTable로 구현된 DataType입니다.   Python에서는 Set이 Value가 Binary인 HashTable로 되어있습니다. 실제 구현 by Python 구현 아이디어:   Dynamic-array  HashCode: import osimport sys# 한글-LUTLUT = {'동': 1, '훈': 2, '명': 3, '수': 4        '형': 5, '돈': 6, '준': 7, '하': 8        '광': 9, '희': 10, '재': 11, '석': 13        '홍': 14, '철': 17}class HashTable:  def __init__(self):    self.Num_of_Slots = 10    self.slots = [None]*10 # dynamic array  # Hash-fun  def _hash(self, name):      global LUT      index = 0      #proc-1      for chr in name:        index += LUT[chr]      #proc-2      index %= self.Num_of_Slots      return index  def insert(self, name, data):    index = self._hash(name)    self.slots[index] = data  def search(self, name):    index = self._hash(name)    value = self.slots[index]    if value: # if it is not None      return value    else:      return None","categories": ["non-linear-ds","basic-ds"],
        "tags": [],
        "url": "http://localhost:4000/non-linear-ds/basic-ds/2020/04/17/Hashtable.html"
      },{
        "title": "카카오 테스트: 외벽 점검",
        "excerpt":"핵심 개념   Complete search  greedy  manage circular case  permutations변수 (1) 몇 명의 친구를 고르는지(2) 어떤 값을 가진 친구들을 고르는 지(3) 고른 친구들은 어떤 순서로 진행하는 지(4) 친구는 각각 어떤 weak 지점부터 시작해야 하는지(5) 친구는 각각 어떤 방향&lt;시계방향, 반시계&gt; 으로 진행해야하는지 풀이법 일단 전체적으로는 Complete Search 문제 입니다.dict와 weak 길이가 충분히 작기 때문에 완전 탐색방법도 Reasonable 하다고 볼 수 있고모든 변수가 독립적으로 결과에 영향을 끼치기 때문에, 최악의 경우 모든 경우의 수를 구해서 대조를 해봐야 합니다. 중복을 최대한 없애고, Greedy한 접근으로 경우의 수 가지치기 하기최악의 경우 모든 경우의 수를 봐야하지만, 우리는 고른 인원의 최솟값만 구하면 되고(greedy)전체적으로 weak가 circular case 라는 것을 집중하면 상당 수의 중복 되는 경우의 수를 가지치기 할 수 있습니다. 먼저, greedy로 가지치기 할 수 있는 부분은 변수 (1)과 (2)입니다.(1)은 outer-loop로 두고 i를 1부터 시작해서, 조건을 만족하는 할 때, 바로 return하게 합니다.(2)은 처음부터 dict를 내림차순으로 지정하여 가장 멀리 갈 수 있는 친구부터 배정합니다. 두 번째, 전체적으로 weak는 둘레가 n인 circular 구조 위에 있습니다.이것을 이용해, (4)과 (5)을 한꺼번에 고려할 수 있습니다. 차례대로 시작 부분을 하나 지정하고, 그 시작을 기준으로 왼쪽과 오른쪽 파트로 나누어서 왼쪽파트는 n값을 플러스 하면 됩니다.Ex) n= 12일떄, [1,5,6,10] -&gt; 5선택 -&gt; [5, 6, 10, 13] , [1,5,6,10] -&gt; 6선택 -&gt; [6, 10, 13, 17] 위의 예처럼 하면 시작지점과 진행방향을 모두 커버할 수 있고(혹시 의심가시면 종이에 몇 가지 예 적어보시면 같은 결과가 나옵니다.)이것은 circular 구조를 고려하지 않아서 모든 weak에 2가지 방향성을 주는 경우에 비해비교 해야할 경우의 수 숫자가 2**n -&gt; n으로 줄어들게 됩니다. 마지막으로 변수 (3)은 어떠한 방식으로도 가지치기를 할 수 없어서 itertools에서 사용하시거나, user-defined로 permutation를 구현하셔서완전탐색을 끝내시면 될 거 같습니다. 구현 by Python import sysimport osdef permutation(candidates, Prepermuation, res):    if len(candidates) == 0: res.append(Prepermuation); return    else:        for i in range(len(candidates)):            permutation(candidates[:i]+candidates[i+1:], Prepermuation + [ candidates[i] ], res)        returndef solution(n, weak, dist):    # complete search    dist.sort(reverse = True)    for i in range(1, len(dist)+1):        permutations = []; permutation(dist[:i], [], permutations)        for p in permutations:            for start in range(len(weak)):                _left = weak[:start]; _right = weak[start:]                traverse_list = _right + [x+n for x in _left]; candidate = p.copy()                while traverse_list and candidate:                    cur = traverse_list.pop(0); d = candidate.pop(0);                    Cover = cur + d                    while traverse_list and traverse_list[0] &lt;= Cover: traverse_list.pop(0)                if not traverse_list:                    return i    return -1","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/17/wall.html"
      },{
        "title": "카카오 테스트:기둥과 보 설치",
        "excerpt":"이 문제는 문제의 효율성 고려나 어려운 개념을 요구하는 게 아니라주어진 복잡한 instruction에 맞추어서 코드로 구현 할 수 있는지를 요구하는 문제입니다.따라서 전체과정을 한 눈에 알아볼 수 있게 도식화하는 능력과 깔끔한 코드를 짜는게 핵심이라고 생각합니다. 핵심 개념:   Matrix rotation  Bit manipulationTIP: 첫 번째, 적당한 Matrix rotation를 이용해서 문제에서 주어지는 Matrix의 좌표를우리가 평소에 사용하는 Matrix의 좌표로 바꾸어 놓고, 문제를 생각하면 좀 더 수월합니다.몇 가지의 경우를 종이에 적어보시면, 어떻게 치환 할 지 패턴이 보이실 겁니다.Ex) n = 5일떄, (0,0) -&gt; (5,0), (0,3) -&gt; (2, 0), (3,4) -&gt; (1, 3)※ 앞: 문제에서 주어진 좌표, 뒤: 우리가 실제 사용할 좌표 두 번째, Bit maninpuation을 이용하면, 설치, 삭제 또는 현재 상태까지 나타낼 수 있습니다.OR: 설치, XOR: 삭제, xxxx: 앞에 두 개의 digit은 기둥의 상태, 뒤에 두 개의 digits은 보의 상태1: 있다 0: 없다로 생각하고 아래와 같이 생각하면 편합니다.Ex) 0000: 아무것도 없다, 1000: 기둥 아랫부분만 있다. ,1100: 기둥 아랫부분 과 기둥 윗부분이 있다.1011: 기둥 아랫부분 과 보의 왼쪽과 보의 오른쪽이 있다., 0001: 보의 오른쪽만 있다. 마지막으로, 이 문제는, 설치보단 삭제 부분이 조금 까다롭습니다.혹시 테스트가 13번 이후로 다 틀린다면, 삭제 부분에서 문제가 있을 확률이 큽니다. 풀이법 저 같은 경우 이걸 아래와 같은 과정을 도식화하여 풀었습니다.   삭제할 좌표에 실제로 보 또는 기둥이 존재하는 지 판단 (없을시 return)  일단 삭제한다고 가정  영향을 끼칠 좌표들의 유효성 검사  영향을 끼칠 좌표들이 모두 유효하다면 삭제 그대로 진행  하나라도 유효하지 않으면, 다시 삭제했던 구조물 재설치import osimport sysdef pillar_alive(coord, matrix):    x, y = coord    pillar_start, pillar_end, bar_start, bar_end = Checker(matrix[x][y])    if pillar_end or bar_start or bar_end: return True    else: return Falsedef bar_alive(coord, matrix, ttype):    x, y = coord    C_pillar_start, C_pillar_end, C_bar_start, C_bar_end = Checker(matrix[x][y])    if ttype == 'left':        L_pillar_start, L_pillar_end, L_bar_start, L_bar_end = Checker(matrix[x][y-1])        if C_pillar_end or L_pillar_end: return True        elif C_bar_start and L_bar_end: return True        else: return False    elif ttype == 'right': # given is start        R_pillar_start, R_pillar_end, R_bar_start, R_bar_end = Checker(matrix[x][y+1])        if C_pillar_end or R_pillar_end: return True        elif C_bar_end and R_bar_start: return True        else: return False    else:        print('IMPOSSIBLE')def Checker(value) -&gt; list:    #result = [pillar's start, pillar's end, bar's start, bar's end]    _bit = '{:04b}'.format(value)    result = []    for _ in _bit:        if _ == '0': result.append(False)        elif _ == '1': result.append(True)        else: print(\"Impossible: \", _)    return resultdef CoordSwapper1(coord, matrix): # problemSetting coord -&gt; build_it coord    x, y = coord    swapped_x = len(matrix) - 1 - y    swapped_y = x    return (swapped_x, swapped_y)def CoordSwapper2(coord, matrix): # built_in coord -&gt; problemSetting coord    x, y = coord    swapped_x = y    swapped_y = len(matrix) - 1 - x    return (swapped_x, swapped_y)def remove_bar(coord, matrix):    x, y = coord    L_pillar_start, L_pillar_end, L_bar_start, L_bar_end = Checker(matrix[x][y])    R_pillar_start, R_pillar_end, R_bar_start, R_bar_end = Checker(matrix[x][y+1])    if not L_bar_start: return    #remove    matrix[x][y]^= 2; matrix[x][y+1]^= 1    L_pillar_TEST = True if (not L_pillar_start) or pillar_alive((x,y), matrix) else False    R_pillar_TEST = True if (not R_pillar_start) or pillar_alive((x, y+1), matrix) else False    L_bar_TEST = True if (not L_bar_end) or bar_alive((x, y), matrix, 'left') else False    R_bar_TEST = True if (not R_bar_start) or bar_alive((x, y+1), matrix, 'right') else False    if L_pillar_TEST and R_pillar_TEST and L_bar_TEST and R_bar_TEST: return    else: matrix[x][y]|= 2; matrix[x][y+1]|= 1 #reinstalldef remove_pillar(coord, matrix):    x, y = coord    D_pillar_start, D_pillar_end, D_bar_start, D_bar_end = Checker(matrix[x][y])    U_pillar_start, U_pillar_end, U_bar_start, U_bar_end = Checker(matrix[x-1][y])    if not D_pillar_start: return    #remove    matrix[x][y]^= 8; matrix[x-1][y]^= 4    U_pillar_TEST = True if (not U_pillar_start) or pillar_alive((x-1, y), matrix) else False    L_bar_TEST = True if (not U_bar_end) or bar_alive((x-1, y), matrix, 'left') else False    R_bar_TEST = True if (not U_bar_start) or bar_alive((x-1, y), matrix, 'right') else False    if U_pillar_TEST and L_bar_TEST and R_bar_TEST: return    else: matrix[x][y]|= 8; matrix[x-1][y]|= 4 # reinstalldef install_pillar(coord, matrix):    x, y = coord    pillar_start, pillar_end, bar_start, bar_end = Checker(matrix[x][y])    if x == len(matrix)-1 or bar_start or bar_end or pillar_end:        matrix[x][y] |= 8        matrix[x-1][y] |= 4def install_bar(coord, matrix):    x, y = coord    L_pillar_start, L_pillar_end, L_bar_start, L_bar_end = Checker(matrix[x][y])    R_pillar_start, R_pillar_end, R_bar_start, R_bar_end = Checker(matrix[x][y+1])    if L_pillar_end or R_pillar_end or (L_bar_end and R_bar_start):        matrix[x][y] |= 2        matrix[x][y+1] |= 1def show_all(matrix, res):    n = len(matrix)    for x in range(n):        for y in range(n):            pillar_start, pillar_end, bar_start, bar_end = Checker(matrix[x][y])            _x, _y = CoordSwapper2( (x, y), matrix)            if pillar_start: res.append([_x,_y,0])            if bar_start: res.append([_x,_y,1])    returndef solution(n, build_frame):    res = []; matrix = [[0]*(n+1) for i in range(n+1)]    for op in build_frame:        x, y, a, b = op        _x, _y = CoordSwapper1((x,y), matrix)        if a == 0 and b == 0: remove_pillar((_x,_y), matrix)        elif a == 0 and b == 1: install_pillar((_x,_y), matrix)        elif a == 1 and b == 0: remove_bar((_x,_y), matrix)        elif a == 1 and b == 1: install_bar((_x,_y), matrix)        else: print(\"IMPOSSIBLE: \", op)    show_all(matrix, res)    res.sort()    return res","categories": ["coding test","kakao 2020 blind"],
        "tags": [],
        "url": "http://localhost:4000/coding%20test/kakao%202020%20blind/2020/04/20/pillar.html"
      }]
